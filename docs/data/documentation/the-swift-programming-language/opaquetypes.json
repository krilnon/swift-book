{
  "abstract" : [
    {
      "text" : "Hide implementation details about a value’s type.",
      "type" : "text"
    }
  ],
  "hierarchy" : {
    "paths" : [
      [
        "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"
      ]
    ]
  },
  "identifier" : {
    "interfaceLanguage" : "swift",
    "url" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes"
  },
  "kind" : "article",
  "metadata" : {
    "title" : "Opaque Types"
  },
  "primaryContentSections" : [
    {
      "content" : [
        {
          "inlineContent" : [
            {
              "text" : "A function or method with an opaque return type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "hides its return value’s type information.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Instead of providing a concrete type as the function’s return type,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the return value is described in terms of the protocols it supports.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Hiding type information",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is useful at boundaries between",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "a module and code that calls into the module,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because the underlying type of the return value can remain private.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Unlike returning a value whose type is a protocol type,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "opaque types preserve type identity —",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the compiler has access to the type information,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but clients of the module don’t.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "The-Problem-That-Opaque-Types-Solve",
          "level" : 2,
          "text" : "The Problem That Opaque Types Solve",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "For example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "suppose you’re writing a module that draws ASCII art shapes.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The basic characteristic of an ASCII art shape",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is a ",
              "type" : "text"
            },
            {
              "code" : "draw()",
              "type" : "codeVoice"
            },
            {
              "text" : " function that returns the string representation of that shape,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which you can use as the requirement for the ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "protocol Shape {",
            "    func draw() -> String",
            "}",
            "",
            "struct Triangle: Shape {",
            "    var size: Int",
            "    func draw() -> String {",
            "       var result: [String] = []",
            "       for length in 1...size {",
            "           result.append(String(repeating: \"*\", count: length))",
            "       }",
            "       return result.joined(separator: \"\\n\")",
            "    }",
            "}",
            "let smallTriangle = Triangle(size: 3)",
            "print(smallTriangle.draw())",
            "\/\/ *",
            "\/\/ **",
            "\/\/ ***"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "You could use generics to implement operations like flipping a shape vertically,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as shown in the code below.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "However, there’s an important limitation to this approach:",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The flipped result exposes the exact generic types",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that were used to create it.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct FlippedShape<T: Shape>: Shape {",
            "    var shape: T",
            "    func draw() -> String {",
            "        let lines = shape.draw().split(separator: \"\\n\")",
            "        return lines.reversed().joined(separator: \"\\n\")",
            "    }",
            "}",
            "let flippedTriangle = FlippedShape(shape: smallTriangle)",
            "print(flippedTriangle.draw())",
            "\/\/ ***",
            "\/\/ **",
            "\/\/ *"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This approach to defining a ",
              "type" : "text"
            },
            {
              "code" : "JoinedShape<T: Shape, U: Shape>",
              "type" : "codeVoice"
            },
            {
              "text" : " structure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that joins two shapes together vertically, like the code below shows,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "results in types like ",
              "type" : "text"
            },
            {
              "code" : "JoinedShape<FlippedShape<Triangle>, Triangle>",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from joining a flipped triangle with another triangle.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct JoinedShape<T: Shape, U: Shape>: Shape {",
            "    var top: T",
            "    var bottom: U",
            "    func draw() -> String {",
            "       return top.draw() + \"\\n\" + bottom.draw()",
            "    }",
            "}",
            "let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)",
            "print(joinedTriangles.draw())",
            "\/\/ *",
            "\/\/ **",
            "\/\/ ***",
            "\/\/ ***",
            "\/\/ **",
            "\/\/ *"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Exposing detailed information about the creation of a shape",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "allows types that aren’t meant to be",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "part of the ASCII art module’s public interface",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to leak out because of the need to state the full return type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The code inside the module",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "could build up the same shape in a variety of ways,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and other code outside the module",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that uses the shape shouldn’t have to account for",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the implementation details about the list of transformations.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Wrapper types like ",
              "type" : "text"
            },
            {
              "code" : "JoinedShape",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "FlippedShape",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "don’t matter to the module’s users,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and they shouldn’t be visible.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The module’s public interface",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "consists of operations like joining and flipping a shape,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and those operations return another ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " value.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Returning-an-Opaque-Type",
          "level" : 2,
          "text" : "Returning an Opaque Type",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can think of an opaque type like being the reverse of a generic type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Generic types let the code that calls a function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "pick the type for that function’s parameters and return value",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in a way that’s abstracted away from the function implementation.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example, the function in the following code",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "returns a type that depends on its caller:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func max<T>(_ x: T, _ y: T) -> T where T: Comparable { ... }"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The code that calls ",
              "type" : "text"
            },
            {
              "code" : "max(_:_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " chooses the values for ",
              "type" : "text"
            },
            {
              "code" : "x",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "y",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the type of those values determines the concrete type of ",
              "type" : "text"
            },
            {
              "code" : "T",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The calling code can use any type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that conforms to the ",
              "type" : "text"
            },
            {
              "code" : "Comparable",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The code inside the function is written in a general way",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so it can handle whatever type the caller provides.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The implementation of ",
              "type" : "text"
            },
            {
              "code" : "max(_:_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " uses only functionality",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that all ",
              "type" : "text"
            },
            {
              "code" : "Comparable",
              "type" : "codeVoice"
            },
            {
              "text" : " types share.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Those roles are reversed for a function with an opaque return type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "An opaque type lets the function implementation",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "pick the type for the value it returns",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in a way that’s abstracted away from the code that calls the function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example, the function in the following example returns a trapezoid",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "without exposing the underlying type of that shape.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Square: Shape {",
            "    var size: Int",
            "    func draw() -> String {",
            "        let line = String(repeating: \"*\", count: size)",
            "        let result = Array<String>(repeating: line, count: size)",
            "        return result.joined(separator: \"\\n\")",
            "    }",
            "}",
            "",
            "func makeTrapezoid() -> some Shape {",
            "    let top = Triangle(size: 2)",
            "    let middle = Square(size: 2)",
            "    let bottom = FlippedShape(shape: top)",
            "    let trapezoid = JoinedShape(",
            "        top: top,",
            "        bottom: JoinedShape(top: middle, bottom: bottom)",
            "    )",
            "    return trapezoid",
            "}",
            "let trapezoid = makeTrapezoid()",
            "print(trapezoid.draw())",
            "\/\/ *",
            "\/\/ **",
            "\/\/ **",
            "\/\/ **",
            "\/\/ **",
            "\/\/ *"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "makeTrapezoid()",
              "type" : "codeVoice"
            },
            {
              "text" : " function in this example",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "declares its return type as ",
              "type" : "text"
            },
            {
              "code" : "some Shape",
              "type" : "codeVoice"
            },
            {
              "text" : ";",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as a result, the function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "returns a value of some given type that conforms to the ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "without specifying any particular concrete type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Writing ",
              "type" : "text"
            },
            {
              "code" : "makeTrapezoid()",
              "type" : "codeVoice"
            },
            {
              "text" : " this way lets it express",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the fundamental aspect of its public interface —",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the value it returns is a shape —",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "without making the specific types that the shape is made from",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "a part of its public interface.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This implementation uses two triangles and a square,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but the function could be rewritten to draw a trapezoid",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in a variety of other ways",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "without changing its return type.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "This example highlights the way that an opaque return type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is like the reverse of a generic type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The code inside ",
              "type" : "text"
            },
            {
              "code" : "makeTrapezoid()",
              "type" : "codeVoice"
            },
            {
              "text" : " can return any type it needs to,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as long as that type conforms to the ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "like the calling code does for a generic function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The code that calls the function needs to be written in a general way,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "like the implementation of a generic function,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so that it can work with any ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " value",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that’s returned by ",
              "type" : "text"
            },
            {
              "code" : "makeTrapezoid()",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can also combine opaque return types with generics.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The functions in the following code both return a value",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "of some type that conforms to the ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func flip<T: Shape>(_ shape: T) -> some Shape {",
            "    return FlippedShape(shape: shape)",
            "}",
            "func join<T: Shape, U: Shape>(_ top: T, _ bottom: U) -> some Shape {",
            "    JoinedShape(top: top, bottom: bottom)",
            "}",
            "",
            "let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))",
            "print(opaqueJoinedTriangles.draw())",
            "\/\/ *",
            "\/\/ **",
            "\/\/ ***",
            "\/\/ ***",
            "\/\/ **",
            "\/\/ *"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The value of ",
              "type" : "text"
            },
            {
              "code" : "opaqueJoinedTriangles",
              "type" : "codeVoice"
            },
            {
              "text" : " in this example",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is the same as ",
              "type" : "text"
            },
            {
              "code" : "joinedTriangles",
              "type" : "codeVoice"
            },
            {
              "text" : " in the generics example",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in the ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : " section earlier in this chapter.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "However, unlike the value in that example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "flip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "join(_:_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " wrap the underlying types",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that the generic shape operations return",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in an opaque return type,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which prevents those types from being visible.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Both functions are generic because the types they rely on are generic,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the type parameters to the function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "pass along the type information needed by ",
              "type" : "text"
            },
            {
              "code" : "FlippedShape",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "JoinedShape",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "If a function with an opaque return type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "returns from multiple places,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "all of the possible return values must have the same type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For a generic function,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that return type can use the function’s generic type parameters,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but it must still be a single type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "here’s an ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "invalid",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " version of the shape-flipping function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that includes a special case for squares:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func invalidFlip<T: Shape>(_ shape: T) -> some Shape {",
            "    if shape is Square {",
            "        return shape \/\/ Error: return types don't match",
            "    }",
            "    return FlippedShape(shape: shape) \/\/ Error: return types don't match",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "If you call this function with a ",
              "type" : "text"
            },
            {
              "code" : "Square",
              "type" : "codeVoice"
            },
            {
              "text" : ", it returns a ",
              "type" : "text"
            },
            {
              "code" : "Square",
              "type" : "codeVoice"
            },
            {
              "text" : ";",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "otherwise, it returns a ",
              "type" : "text"
            },
            {
              "code" : "FlippedShape",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This violates the requirement to return values of only one type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and makes ",
              "type" : "text"
            },
            {
              "code" : "invalidFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " invalid code.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "One way to fix ",
              "type" : "text"
            },
            {
              "code" : "invalidFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " is to move the special case for squares",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "into the implementation of ",
              "type" : "text"
            },
            {
              "code" : "FlippedShape",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which lets this function always return a ",
              "type" : "text"
            },
            {
              "code" : "FlippedShape",
              "type" : "codeVoice"
            },
            {
              "text" : " value:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct FlippedShape<T: Shape>: Shape {",
            "    var shape: T",
            "    func draw() -> String {",
            "        if shape is Square {",
            "           return shape.draw()",
            "        }",
            "        let lines = shape.draw().split(separator: \"\\n\")",
            "        return lines.reversed().joined(separator: \"\\n\")",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The requirement to always return a single type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "doesn’t prevent you from using generics in an opaque return type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Here’s an example of a function that incorporates its type parameter",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "into the underlying type of the value it returns:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func `repeat`<T: Shape>(shape: T, count: Int) -> some Collection {",
            "    return Array<T>(repeating: shape, count: count)",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "In this case,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the underlying type of the return value",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "varies depending on ",
              "type" : "text"
            },
            {
              "code" : "T",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Whatever shape is passed it,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "repeat(shape:count:)",
              "type" : "codeVoice"
            },
            {
              "text" : " creates and returns an array of that shape.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Nevertheless,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the return value always has the same underlying type of ",
              "type" : "text"
            },
            {
              "code" : "[T]",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so it follows the requirement that functions with opaque return types",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "must return values of only a single type.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Differences-Between-Opaque-Types-and-Protocol-Types",
          "level" : 2,
          "text" : "Differences Between Opaque Types and Protocol Types",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Returning an opaque type looks very similar",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to using a protocol type as the return type of a function,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but these two kinds of return type differ in",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "whether they preserve type identity.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "An opaque type refers to one specific type,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "although the caller of the function isn’t able to see which type;",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "a protocol type can refer to any type that conforms to the protocol.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Generally speaking,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "protocol types give you more flexibility",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "about the underlying types of the values they store,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and opaque types let you make stronger guarantees",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "about those underlying types.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "For example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "here’s a version of ",
              "type" : "text"
            },
            {
              "code" : "flip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that uses a protocol type as its return type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "instead of an opaque return type:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func protoFlip<T: Shape>(_ shape: T) -> Shape {",
            "    return FlippedShape(shape: shape)",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This version of ",
              "type" : "text"
            },
            {
              "code" : "protoFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "has the same body as ",
              "type" : "text"
            },
            {
              "code" : "flip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and it always returns a value of the same type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Unlike ",
              "type" : "text"
            },
            {
              "code" : "flip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the value that ",
              "type" : "text"
            },
            {
              "code" : "protoFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " returns isn’t required",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to always have the same type —",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it just has to conform to the ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Put another way,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "protoFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " makes a much looser API contract with its caller",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "than ",
              "type" : "text"
            },
            {
              "code" : "flip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " makes.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It reserves the flexibility to return values of multiple types:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func protoFlip<T: Shape>(_ shape: T) -> Shape {",
            "    if shape is Square {",
            "        return shape",
            "    }",
            "",
            "    return FlippedShape(shape: shape)",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The revised version of the code returns",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "an instance of ",
              "type" : "text"
            },
            {
              "code" : "Square",
              "type" : "codeVoice"
            },
            {
              "text" : " or an instance of ",
              "type" : "text"
            },
            {
              "code" : "FlippedShape",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "depending on what shape is passed in.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Two flipped shapes returned by this function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "might have completely different types.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Other valid versions of this function could return values of different types",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when flipping multiple instances of the same shape.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The less specific return type information from ",
              "type" : "text"
            },
            {
              "code" : "protoFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " means that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "many operations that depend on type information",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "aren’t available on the returned value.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example, it’s not possible to write an ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "comparing results returned by this function.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let protoFlippedTriangle = protoFlip(smallTriangle)",
            "let sameThing = protoFlip(smallTriangle)",
            "protoFlippedTriangle == sameThing  \/\/ Error"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The error on the last line of the example occurs for several reasons.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The immediate issue is that the ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " doesn’t include an ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as part of its protocol requirements.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "If you try adding one, the next issue you’ll encounter",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is that the ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator needs to know",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the types of its left-hand and right-hand arguments.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This sort of operator usually takes arguments of type ",
              "type" : "text"
            },
            {
              "code" : "Self",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "matching whatever concrete type adopts the protocol,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but adding a ",
              "type" : "text"
            },
            {
              "code" : "Self",
              "type" : "codeVoice"
            },
            {
              "text" : " requirement to the protocol",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "doesn’t allow for the type erasure that happens",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when you use the protocol as a type.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Using a protocol type as the return type for a function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "gives you the flexibility to return any type that conforms to the protocol.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "However, the cost of that flexibility",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is that some operations aren’t possible on the returned values.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The example shows how the ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator isn’t available —",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it depends on specific type information",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that isn’t preserved by using a protocol type.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Another problem with this approach is that the shape transformations don’t nest.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The result of flipping a triangle is a value of type ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the ",
              "type" : "text"
            },
            {
              "code" : "protoFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function takes an argument",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "of some type that conforms to the ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "However, a value of a protocol type doesn’t conform to that protocol;",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the value returned by ",
              "type" : "text"
            },
            {
              "code" : "protoFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " doesn’t conform to ",
              "type" : "text"
            },
            {
              "code" : "Shape",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This means code like ",
              "type" : "text"
            },
            {
              "code" : "protoFlip(protoFlip(smallTriangle))",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that applies multiple transformations is invalid",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because the flipped shape isn’t a valid argument to ",
              "type" : "text"
            },
            {
              "code" : "protoFlip(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In contrast,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "opaque types preserve the identity of the underlying type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift can infer associated types,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which lets you use an opaque return value",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in places where a protocol type can’t be used as a return value.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "here’s a version of the ",
              "type" : "text"
            },
            {
              "code" : "Container",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol from ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "protocol Container {",
            "    associatedtype Item",
            "    var count: Int { get }",
            "    subscript(i: Int) -> Item { get }",
            "}",
            "extension Array: Container { }"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can’t use ",
              "type" : "text"
            },
            {
              "code" : "Container",
              "type" : "codeVoice"
            },
            {
              "text" : " as the return type of a function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because that protocol has an associated type.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "You also can’t use it as constraint in a generic return type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because there isn’t enough information outside the function body",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to infer what the generic type needs to be.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "\/\/ Error: Protocol with associated types can't be used as a return type.",
            "func makeProtocolContainer<T>(item: T) -> Container {",
            "    return [item]",
            "}",
            "",
            "\/\/ Error: Not enough information to infer C.",
            "func makeProtocolContainer<T, C: Container>(item: T) -> C {",
            "    return [item]",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Using the opaque type ",
              "type" : "text"
            },
            {
              "code" : "some Container",
              "type" : "codeVoice"
            },
            {
              "text" : " as a return type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "expresses the desired API contract — the function returns a container,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but declines to specify the container’s type:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func makeOpaqueContainer<T>(item: T) -> some Container {",
            "    return [item]",
            "}",
            "let opaqueContainer = makeOpaqueContainer(item: 12)",
            "let twelve = opaqueContainer[0]",
            "print(type(of: twelve))",
            "\/\/ Prints \"Int\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The type of ",
              "type" : "text"
            },
            {
              "code" : "twelve",
              "type" : "codeVoice"
            },
            {
              "text" : " is inferred to be ",
              "type" : "text"
            },
            {
              "code" : "Int",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which illustrates the fact that type inference works with opaque types.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In the implementation of ",
              "type" : "text"
            },
            {
              "code" : "makeOpaqueContainer(item:)",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the underlying type of the opaque container is ",
              "type" : "text"
            },
            {
              "code" : "[T]",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In this case, ",
              "type" : "text"
            },
            {
              "code" : "T",
              "type" : "codeVoice"
            },
            {
              "text" : " is ",
              "type" : "text"
            },
            {
              "code" : "Int",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so the return value is an array of integers",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the ",
              "type" : "text"
            },
            {
              "code" : "Item",
              "type" : "codeVoice"
            },
            {
              "text" : " associated type is inferred to be ",
              "type" : "text"
            },
            {
              "code" : "Int",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The subscript on ",
              "type" : "text"
            },
            {
              "code" : "Container",
              "type" : "codeVoice"
            },
            {
              "text" : " returns ",
              "type" : "text"
            },
            {
              "code" : "Item",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which means that the type of ",
              "type" : "text"
            },
            {
              "code" : "twelve",
              "type" : "codeVoice"
            },
            {
              "text" : " is also inferred to be ",
              "type" : "text"
            },
            {
              "code" : "Int",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        }
      ],
      "kind" : "content"
    }
  ],
  "schemaVersion" : {
    "major" : 0,
    "minor" : 3,
    "patch" : 0
  },
  "sections" : [

  ]
, 
"references": {
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language",
  "kind" : "article",
  "role" : "collection",
  "title" : "The Swift Programming Language",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics": {
  "abstract" : [
    {
      "text" : "Write code that works for multiple types and specify requirements for those types.",
      "type" : "text"
    }
  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics",
  "kind" : "article",
  "role" : "article",
  "title" : "Generics",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/generics"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes#The-Problem-That-Opaque-Types-Solve": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve",
  "kind" : "section",
  "title" : "The Problem That Opaque Types Solve",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/opaquetypes#The-Problem-That-Opaque-Types-Solve"
}
}
}