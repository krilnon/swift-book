{
  "abstract" : [
    {
      "text" : "Group code that executes together, without creating a named function.",
      "type" : "text"
    }
  ],
  "hierarchy" : {
    "paths" : [
      [
        "doc:\/\/org.swift.tspl\/documentation\/TSPL"
      ]
    ]
  },
  "identifier" : {
    "interfaceLanguage" : "swift",
    "url" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures"
  },
  "kind" : "article",
  "metadata" : {
    "title" : "Closures"
  },
  "primaryContentSections" : [
    {
      "content" : [
        {
          "anchor" : "overview",
          "level" : 2,
          "text" : "Overview",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "inlineContent" : [
                {
                  "text" : "Closures",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " are self-contained blocks of functionality",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that can be passed around and used in your code.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Closures in Swift are similar to blocks in C and Objective-C",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and to lambdas in other programming languages.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Closures can capture and store references to any constants and variables",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from the context in which they’re defined.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This is known as ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "closing over",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " those constants and variables.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift handles all of the memory management of capturing for you.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "Don’t worry if you aren’t familiar with the concept of capturing.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "It’s explained in detail below in ",
                  "type" : "text"
                },
                {
                  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Capturing-Values",
                  "isActive" : true,
                  "type" : "reference"
                },
                {
                  "text" : ".",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "inlineContent" : [
            {
              "text" : "Global and nested functions, as introduced in ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "are actually special cases of closures.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Closures take one of three forms:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Global functions are closures that have a name",
                      "type" : "text"
                    },
                    {
                      "text" : " ",
                      "type" : "text"
                    },
                    {
                      "text" : "and don’t capture any values.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Nested functions are closures that have a name",
                      "type" : "text"
                    },
                    {
                      "text" : " ",
                      "type" : "text"
                    },
                    {
                      "text" : "and can capture values from their enclosing function.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Closure expressions are unnamed closures written in a lightweight syntax",
                      "type" : "text"
                    },
                    {
                      "text" : " ",
                      "type" : "text"
                    },
                    {
                      "text" : "that can capture values from their surrounding context.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            }
          ],
          "type" : "unorderedList"
        },
        {
          "inlineContent" : [
            {
              "text" : "Swift’s closure expressions have a clean, clear style,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with optimizations that encourage brief, clutter-free syntax in common scenarios.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "These optimizations include:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Inferring parameter and return value types from context",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Implicit returns from single-expression closures",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Shorthand argument names",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Trailing closure syntax",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            }
          ],
          "type" : "unorderedList"
        },
        {
          "anchor" : "Closure-Expressions",
          "level" : 2,
          "text" : "Closure Expressions",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Nested functions, as introduced in ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Nested-Functions",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "are a convenient means of naming and defining self-contained blocks of code",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as part of a larger function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "However, it’s sometimes useful to write shorter versions of function-like constructs",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "without a full declaration and name.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This is particularly true when you work with functions or methods that take functions",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as one or more of their arguments.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "inlineContent" : [
                {
                  "text" : "Closure expressions",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " are a way to write inline closures in a brief, focused syntax.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Closure expressions provide several syntax optimizations",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "for writing closures in a shortened form without loss of clarity or intent.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The closure expression examples below illustrate these optimizations",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by refining a single example of the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method over several iterations,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "each of which expresses the same functionality in a more succinct way.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "The-Sorted-Method",
          "level" : 3,
          "text" : "The Sorted Method",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Swift’s standard library provides a method called ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which sorts an array of values of a known type,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "based on the output of a sorting closure that you provide.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Once it completes the sorting process,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method returns a new array of the same type and size as the old one,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with its elements in the correct sorted order.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The original array isn’t modified by the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The closure expression examples below use the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to sort an array of ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " values in reverse alphabetical order.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Here’s the initial array to be sorted:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method accepts a closure that takes two arguments",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "of the same type as the array’s contents,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and returns a ",
              "type" : "text"
            },
            {
              "code" : "Bool",
              "type" : "codeVoice"
            },
            {
              "text" : " value to say whether the first value should appear",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "before or after the second value once the values are sorted.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The sorting closure needs to return ",
              "type" : "text"
            },
            {
              "code" : "true",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "if the first value should appear ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "before",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " the second value,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and ",
              "type" : "text"
            },
            {
              "code" : "false",
              "type" : "codeVoice"
            },
            {
              "text" : " otherwise.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "This example is sorting an array of ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " values,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and so the sorting closure needs to be a function of type ",
              "type" : "text"
            },
            {
              "code" : "(String, String) -> Bool",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "One way to provide the sorting closure is to write a normal function of the correct type,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and to pass it in as an argument to the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func backward(_ s1: String, _ s2: String) -> Bool {",
            "    return s1 > s2",
            "}",
            "var reversedNames = names.sorted(by: backward)",
            "\/\/ reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "If the first string (",
              "type" : "text"
            },
            {
              "code" : "s1",
              "type" : "codeVoice"
            },
            {
              "text" : ") is greater than the second string (",
              "type" : "text"
            },
            {
              "code" : "s2",
              "type" : "codeVoice"
            },
            {
              "text" : "),",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "backward(_:_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function will return ",
              "type" : "text"
            },
            {
              "code" : "true",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "indicating that ",
              "type" : "text"
            },
            {
              "code" : "s1",
              "type" : "codeVoice"
            },
            {
              "text" : " should appear before ",
              "type" : "text"
            },
            {
              "code" : "s2",
              "type" : "codeVoice"
            },
            {
              "text" : " in the sorted array.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For characters in strings,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "“greater than” means “appears later in the alphabet than”.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This means that the letter ",
              "type" : "text"
            },
            {
              "code" : "\"B\"",
              "type" : "codeVoice"
            },
            {
              "text" : " is “greater than” the letter ",
              "type" : "text"
            },
            {
              "code" : "\"A\"",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the string ",
              "type" : "text"
            },
            {
              "code" : "\"Tom\"",
              "type" : "codeVoice"
            },
            {
              "text" : " is greater than the string ",
              "type" : "text"
            },
            {
              "code" : "\"Tim\"",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This gives a reverse alphabetical sort,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with ",
              "type" : "text"
            },
            {
              "code" : "\"Barry\"",
              "type" : "codeVoice"
            },
            {
              "text" : " being placed before ",
              "type" : "text"
            },
            {
              "code" : "\"Alex\"",
              "type" : "codeVoice"
            },
            {
              "text" : ", and so on.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "However, this is a rather long-winded way to write",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "what is essentially a single-expression function (",
              "type" : "text"
            },
            {
              "code" : "a > b",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In this example, it would be preferable to write the sorting closure inline,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "using closure expression syntax.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Closure-Expression-Syntax",
          "level" : 3,
          "text" : "Closure Expression Syntax",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Closure expression syntax has the following general form:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "{ (<#parameters#>) -> <#return type#> in",
            "   <#statements#>",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "parameters",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " in closure expression syntax",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "can be in-out parameters,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but they can’t have a default value.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Variadic parameters can be used if you name the variadic parameter.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Tuples can also be used as parameter types and return types.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example below shows a closure expression version of the ",
              "type" : "text"
            },
            {
              "code" : "backward(_:_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from above:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in",
            "    return s1 > s2",
            "})"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Note that the declaration of parameters and return type for this inline closure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is identical to the declaration from the ",
              "type" : "text"
            },
            {
              "code" : "backward(_:_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In both cases, it’s written as ",
              "type" : "text"
            },
            {
              "code" : "(s1: String, s2: String) -> Bool",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "However, for the inline closure expression,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the parameters and return type are written ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "inside",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " the curly braces,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "not outside of them.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The start of the closure’s body is introduced by the ",
              "type" : "text"
            },
            {
              "code" : "in",
              "type" : "codeVoice"
            },
            {
              "text" : " keyword.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This keyword indicates that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the definition of the closure’s parameters and return type has finished,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the body of the closure is about to begin.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Because the body of the closure is so short,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it can even be written on a single line:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This illustrates that the overall call to the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method has remained the same.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "A pair of parentheses still wrap the entire argument for the method.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "However, that argument is now an inline closure.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Inferring-Type-From-Context",
          "level" : 3,
          "text" : "Inferring Type From Context",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Because the sorting closure is passed as an argument to a method,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift can infer the types of its parameters",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the type of the value it returns.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method is being called on an array of strings,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so its argument must be a function of type ",
              "type" : "text"
            },
            {
              "code" : "(String, String) -> Bool",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This means that the ",
              "type" : "text"
            },
            {
              "code" : "(String, String)",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "Bool",
              "type" : "codeVoice"
            },
            {
              "text" : " types don’t need to be written",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as part of the closure expression’s definition.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because all of the types can be inferred,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the return arrow (",
              "type" : "text"
            },
            {
              "code" : "->",
              "type" : "codeVoice"
            },
            {
              "text" : ") and the parentheses around the names of the parameters",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "can also be omitted:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "It’s always possible to infer the parameter types and return type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when passing a closure to a function or method as an inline closure expression.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "As a result, you never need to write an inline closure in its fullest form",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when the closure is used as a function or method argument.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Nonetheless, you can still make the types explicit if you wish,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and doing so is encouraged if it avoids ambiguity for readers of your code.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In the case of the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the purpose of the closure is clear from the fact that sorting is taking place,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and it’s safe for a reader to assume that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the closure is likely to be working with ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " values,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because it’s assisting with the sorting of an array of strings.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Implicit-Returns-from-Single-Expression-Closures",
          "level" : 3,
          "text" : "Implicit Returns from Single-Expression Closures",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Single-expression closures can implicitly return the result of their single expression",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by omitting the ",
              "type" : "text"
            },
            {
              "code" : "return",
              "type" : "codeVoice"
            },
            {
              "text" : " keyword from their declaration,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as in this version of the previous example:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here, the function type of the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method’s argument",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "makes it clear that a ",
              "type" : "text"
            },
            {
              "code" : "Bool",
              "type" : "codeVoice"
            },
            {
              "text" : " value must be returned by the closure.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because the closure’s body contains a single expression (",
              "type" : "text"
            },
            {
              "code" : "s1 > s2",
              "type" : "codeVoice"
            },
            {
              "text" : ")",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that returns a ",
              "type" : "text"
            },
            {
              "code" : "Bool",
              "type" : "codeVoice"
            },
            {
              "text" : " value,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "there’s no ambiguity, and the ",
              "type" : "text"
            },
            {
              "code" : "return",
              "type" : "codeVoice"
            },
            {
              "text" : " keyword can be omitted.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Shorthand-Argument-Names",
          "level" : 3,
          "text" : "Shorthand Argument Names",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Swift automatically provides shorthand argument names to inline closures,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which can be used to refer to the values of the closure’s arguments",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by the names ",
              "type" : "text"
            },
            {
              "code" : "$0",
              "type" : "codeVoice"
            },
            {
              "text" : ", ",
              "type" : "text"
            },
            {
              "code" : "$1",
              "type" : "codeVoice"
            },
            {
              "text" : ", ",
              "type" : "text"
            },
            {
              "code" : "$2",
              "type" : "codeVoice"
            },
            {
              "text" : ", and so on.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "If you use these shorthand argument names within your closure expression,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you can omit the closure’s argument list from its definition.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The type of the shorthand argument names",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is inferred from the expected function type,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the highest numbered shorthand argument you use",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "determines the number of arguments that the closure takes.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "in",
              "type" : "codeVoice"
            },
            {
              "text" : " keyword can also be omitted,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because the closure expression is made up entirely of its body:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "reversedNames = names.sorted(by: { $0 > $1 } )"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here, ",
              "type" : "text"
            },
            {
              "code" : "$0",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "$1",
              "type" : "codeVoice"
            },
            {
              "text" : " refer to the closure’s first and second ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " arguments.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because ",
              "type" : "text"
            },
            {
              "code" : "$1",
              "type" : "codeVoice"
            },
            {
              "text" : " is the shorthand argument with highest number,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the closure is understood to take two arguments.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function here expects a closure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "whose arguments are both strings,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the shorthand arguments ",
              "type" : "text"
            },
            {
              "code" : "$0",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "$1",
              "type" : "codeVoice"
            },
            {
              "text" : " are both of type ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Operator-Methods",
          "level" : 3,
          "text" : "Operator Methods",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "There’s actually an even ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "shorter",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " way to write the closure expression above.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift’s ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " type defines its string-specific implementation of",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the greater-than operator (",
              "type" : "text"
            },
            {
              "code" : ">",
              "type" : "codeVoice"
            },
            {
              "text" : ")",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as a method that has two parameters of type ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and returns a value of type ",
              "type" : "text"
            },
            {
              "code" : "Bool",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This exactly matches the method type needed by the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Therefore, you can simply pass in the greater-than operator,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and Swift will infer that you want to use its string-specific implementation:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "reversedNames = names.sorted(by: >)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "For more about operator methods, see ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Operator-Methods",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Trailing-Closures",
          "level" : 2,
          "text" : "Trailing Closures",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "If you need to pass a closure expression to a function as the function’s final argument",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the closure expression is long,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it can be useful to write it as a ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "trailing closure",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " instead.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "You write a trailing closure after the function call’s parentheses,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "even though the trailing closure is still an argument to the function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "When you use the trailing closure syntax,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you don’t write the argument label for the first closure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as part of the function call.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "A function call can include multiple trailing closures;",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "however, the first few examples below use a single trailing closure.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func someFunctionThatTakesAClosure(closure: () -> Void) {",
            "    \/\/ function body goes here",
            "}",
            "",
            "\/\/ Here's how you call this function without using a trailing closure:",
            "",
            "someFunctionThatTakesAClosure(closure: {",
            "    \/\/ closure's body goes here",
            "})",
            "",
            "\/\/ Here's how you call this function with a trailing closure instead:",
            "",
            "someFunctionThatTakesAClosure() {",
            "    \/\/ trailing closure's body goes here",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The string-sorting closure from the ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expression-Syntax",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : " section above",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "can be written outside of the ",
              "type" : "text"
            },
            {
              "code" : "sorted(by:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method’s parentheses as a trailing closure:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "reversedNames = names.sorted() { $0 > $1 }"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "If a closure expression is provided as the function’s or method’s only argument",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and you provide that expression as a trailing closure,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you don’t need to write a pair of parentheses ",
              "type" : "text"
            },
            {
              "code" : "()",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "after the function or method’s name when you call the function:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "reversedNames = names.sorted { $0 > $1 }"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Trailing closures are most useful when the closure is sufficiently long that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it isn’t possible to write it inline on a single line.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "As an example, Swift’s ",
              "type" : "text"
            },
            {
              "code" : "Array",
              "type" : "codeVoice"
            },
            {
              "text" : " type has a ",
              "type" : "text"
            },
            {
              "code" : "map(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which takes a closure expression as its single argument.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The closure is called once for each item in the array,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and returns an alternative mapped value (possibly of some other type) for that item.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "You specify",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the nature of the mapping and the type of the returned value",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by writing code in the closure that you pass to ",
              "type" : "text"
            },
            {
              "code" : "map(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "After applying the provided closure to each array element,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "map(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method returns a new array containing all of the new mapped values,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in the same order as their corresponding values in the original array.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here’s how you can use the ",
              "type" : "text"
            },
            {
              "code" : "map(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method with a trailing closure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to convert an array of ",
              "type" : "text"
            },
            {
              "code" : "Int",
              "type" : "codeVoice"
            },
            {
              "text" : " values into an array of ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " values.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The array ",
              "type" : "text"
            },
            {
              "code" : "[16, 58, 510]",
              "type" : "codeVoice"
            },
            {
              "text" : " is used to create the new array",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "[\"OneSix\", \"FiveEight\", \"FiveOneZero\"]",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let digitNames = [",
            "    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",",
            "    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"",
            "]",
            "let numbers = [16, 58, 510]"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The code above creates a dictionary of mappings between",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the integer digits and English-language versions of their names.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It also defines an array of integers, ready to be converted into strings.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can now use the ",
              "type" : "text"
            },
            {
              "code" : "numbers",
              "type" : "codeVoice"
            },
            {
              "text" : " array to create an array of ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " values,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by passing a closure expression to the array’s ",
              "type" : "text"
            },
            {
              "code" : "map(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method as a trailing closure:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let strings = numbers.map { (number) -> String in",
            "    var number = number",
            "    var output = \"\"",
            "    repeat {",
            "        output = digitNames[number % 10]! + output",
            "        number \/= 10",
            "    } while number > 0",
            "    return output",
            "}",
            "\/\/ strings is inferred to be of type [String]",
            "\/\/ its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "map(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method calls the closure expression once for each item in the array.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "You don’t need to specify the type of the closure’s input parameter, ",
              "type" : "text"
            },
            {
              "code" : "number",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because the type can be inferred from the values in the array to be mapped.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In this example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the variable ",
              "type" : "text"
            },
            {
              "code" : "number",
              "type" : "codeVoice"
            },
            {
              "text" : " is initialized with the value of the closure’s ",
              "type" : "text"
            },
            {
              "code" : "number",
              "type" : "codeVoice"
            },
            {
              "text" : " parameter,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so that the value can be modified within the closure body.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "(The parameters to functions and closures are always constants.)",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The closure expression also specifies a return type of ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to indicate the type that will be stored in the mapped output array.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The closure expression builds a string called ",
              "type" : "text"
            },
            {
              "code" : "output",
              "type" : "codeVoice"
            },
            {
              "text" : " each time it’s called.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It calculates the last digit of ",
              "type" : "text"
            },
            {
              "code" : "number",
              "type" : "codeVoice"
            },
            {
              "text" : " by using the remainder operator (",
              "type" : "text"
            },
            {
              "code" : "number % 10",
              "type" : "codeVoice"
            },
            {
              "text" : "),",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and uses this digit to look up an appropriate string in the ",
              "type" : "text"
            },
            {
              "code" : "digitNames",
              "type" : "codeVoice"
            },
            {
              "text" : " dictionary.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The closure can be used to create a string representation of any integer greater than zero.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "The call to the ",
                  "type" : "text"
                },
                {
                  "code" : "digitNames",
                  "type" : "codeVoice"
                },
                {
                  "text" : " dictionary’s subscript",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "is followed by an exclamation point (",
                  "type" : "text"
                },
                {
                  "code" : "!",
                  "type" : "codeVoice"
                },
                {
                  "text" : "),",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "because dictionary subscripts return an optional value",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "to indicate that the dictionary lookup can fail if the key doesn’t exist.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "In the example above, it’s guaranteed that ",
                  "type" : "text"
                },
                {
                  "code" : "number % 10",
                  "type" : "codeVoice"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "will always be a valid subscript key for the ",
                  "type" : "text"
                },
                {
                  "code" : "digitNames",
                  "type" : "codeVoice"
                },
                {
                  "text" : " dictionary,",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "and so an exclamation point is used to force-unwrap the ",
                  "type" : "text"
                },
                {
                  "code" : "String",
                  "type" : "codeVoice"
                },
                {
                  "text" : " value",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "stored in the subscript’s optional return value.",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "inlineContent" : [
            {
              "text" : "The string retrieved from the ",
              "type" : "text"
            },
            {
              "code" : "digitNames",
              "type" : "codeVoice"
            },
            {
              "text" : " dictionary",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is added to the ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "front",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " of ",
              "type" : "text"
            },
            {
              "code" : "output",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "effectively building a string version of the number in reverse.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "(The expression ",
              "type" : "text"
            },
            {
              "code" : "number % 10",
              "type" : "codeVoice"
            },
            {
              "text" : " gives a value of",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "6",
              "type" : "codeVoice"
            },
            {
              "text" : " for ",
              "type" : "text"
            },
            {
              "code" : "16",
              "type" : "codeVoice"
            },
            {
              "text" : ", ",
              "type" : "text"
            },
            {
              "code" : "8",
              "type" : "codeVoice"
            },
            {
              "text" : " for ",
              "type" : "text"
            },
            {
              "code" : "58",
              "type" : "codeVoice"
            },
            {
              "text" : ", and ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : " for ",
              "type" : "text"
            },
            {
              "code" : "510",
              "type" : "codeVoice"
            },
            {
              "text" : ".)",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "number",
              "type" : "codeVoice"
            },
            {
              "text" : " variable is then divided by ",
              "type" : "text"
            },
            {
              "code" : "10",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because it’s an integer, it’s rounded down during the division,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so ",
              "type" : "text"
            },
            {
              "code" : "16",
              "type" : "codeVoice"
            },
            {
              "text" : " becomes ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : ", ",
              "type" : "text"
            },
            {
              "code" : "58",
              "type" : "codeVoice"
            },
            {
              "text" : " becomes ",
              "type" : "text"
            },
            {
              "code" : "5",
              "type" : "codeVoice"
            },
            {
              "text" : ", and ",
              "type" : "text"
            },
            {
              "code" : "510",
              "type" : "codeVoice"
            },
            {
              "text" : " becomes ",
              "type" : "text"
            },
            {
              "code" : "51",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The process is repeated until ",
              "type" : "text"
            },
            {
              "code" : "number",
              "type" : "codeVoice"
            },
            {
              "text" : " is equal to ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "at which point the ",
              "type" : "text"
            },
            {
              "code" : "output",
              "type" : "codeVoice"
            },
            {
              "text" : " string is returned by the closure,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and is added to the output array by the ",
              "type" : "text"
            },
            {
              "code" : "map(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The use of trailing closure syntax in the example above",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "neatly encapsulates the closure’s functionality",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "immediately after the function that closure supports,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "without needing to wrap the entire closure within",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "map(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method’s outer parentheses.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "If a function takes multiple closures,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you omit the argument label for the first trailing closure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and you label the remaining trailing closures.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the function below loads a picture for a photo gallery:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {",
            "    if let picture = download(\"photo.jpg\", from: server) {",
            "        completion(picture)",
            "    } else {",
            "        onFailure()",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "When you call this function to load a picture,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you provide two closures.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The first closure is a completion handler",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that displays a picture after a successful download.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The second closure is an error handler",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that displays an error to the user.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "loadPicture(from: someServer) { picture in",
            "    someView.currentPicture = picture",
            "} onFailure: {",
            "    print(\"Couldn't download the next picture.\")",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "In this example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "loadPicture(from:completion:onFailure:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "dispatches its network task into the background,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and calls one of the two completion handlers when the network task finishes.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Writing the function this way lets you cleanly separate the code",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that’s responsible for handling a network failure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from the code that updates the user interface after a successful download,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "instead of using just one closure that handles both circumstances.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "Completion handlers can become hard to read,",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "especially when you have to nest multiple handlers.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "An alternate approach is to use asynchronous code,",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "as described in ",
                  "type" : "text"
                },
                {
                  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency",
                  "isActive" : true,
                  "type" : "reference"
                },
                {
                  "text" : ".",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "anchor" : "Capturing-Values",
          "level" : 2,
          "text" : "Capturing Values",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "A closure can ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "capture",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " constants and variables",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from the surrounding context in which it’s defined.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The closure can then refer to and modify",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the values of those constants and variables from within its body,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "even if the original scope that defined the constants and variables no longer exists.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In Swift, the simplest form of a closure that can capture values is a nested function,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "written within the body of another function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "A nested function can capture any of its outer function’s arguments",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and can also capture any constants and variables defined within the outer function.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here’s an example of a function called ",
              "type" : "text"
            },
            {
              "code" : "makeIncrementer",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which contains a nested function called ",
              "type" : "text"
            },
            {
              "code" : "incrementer",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The nested ",
              "type" : "text"
            },
            {
              "code" : "incrementer()",
              "type" : "codeVoice"
            },
            {
              "text" : " function captures two values,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "amount",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from its surrounding context.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "After capturing these values,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "incrementer",
              "type" : "codeVoice"
            },
            {
              "text" : " is returned by ",
              "type" : "text"
            },
            {
              "code" : "makeIncrementer",
              "type" : "codeVoice"
            },
            {
              "text" : " as a closure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that increments ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " by ",
              "type" : "text"
            },
            {
              "code" : "amount",
              "type" : "codeVoice"
            },
            {
              "text" : " each time it’s called.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func makeIncrementer(forIncrement amount: Int) -> () -> Int {",
            "    var runningTotal = 0",
            "    func incrementer() -> Int {",
            "        runningTotal += amount",
            "        return runningTotal",
            "    }",
            "    return incrementer",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The return type of ",
              "type" : "text"
            },
            {
              "code" : "makeIncrementer",
              "type" : "codeVoice"
            },
            {
              "text" : " is ",
              "type" : "text"
            },
            {
              "code" : "() -> Int",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This means that it returns a ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "function",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ", rather than a simple value.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The function it returns has no parameters,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and returns an ",
              "type" : "text"
            },
            {
              "code" : "Int",
              "type" : "codeVoice"
            },
            {
              "text" : " value each time it’s called.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "To learn how functions can return other functions,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "see ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Function-Types-as-Return-Types",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "makeIncrementer(forIncrement:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function defines an integer variable called ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to store the current running total of the incrementer that will be returned.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This variable is initialized with a value of ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "makeIncrementer(forIncrement:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function has a single ",
              "type" : "text"
            },
            {
              "code" : "Int",
              "type" : "codeVoice"
            },
            {
              "text" : " parameter",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with an argument label of ",
              "type" : "text"
            },
            {
              "code" : "forIncrement",
              "type" : "codeVoice"
            },
            {
              "text" : ", and a parameter name of ",
              "type" : "text"
            },
            {
              "code" : "amount",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The argument value passed to this parameter specifies",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "how much ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " should be incremented by",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "each time the returned incrementer function is called.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "makeIncrementer",
              "type" : "codeVoice"
            },
            {
              "text" : " function defines a nested function called ",
              "type" : "text"
            },
            {
              "code" : "incrementer",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which performs the actual incrementing.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This function simply adds ",
              "type" : "text"
            },
            {
              "code" : "amount",
              "type" : "codeVoice"
            },
            {
              "text" : " to ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : ", and returns the result.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "When considered in isolation,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the nested ",
              "type" : "text"
            },
            {
              "code" : "incrementer()",
              "type" : "codeVoice"
            },
            {
              "text" : " function might seem unusual:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func incrementer() -> Int {",
            "    runningTotal += amount",
            "    return runningTotal",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "incrementer()",
              "type" : "codeVoice"
            },
            {
              "text" : " function doesn’t have any parameters,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and yet it refers to ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "amount",
              "type" : "codeVoice"
            },
            {
              "text" : " from within its function body.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It does this by capturing a ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "reference",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " to ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "amount",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from the surrounding function and using them within its own function body.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Capturing by reference ensures that ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "amount",
              "type" : "codeVoice"
            },
            {
              "text" : " don’t disappear",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when the call to ",
              "type" : "text"
            },
            {
              "code" : "makeIncrementer",
              "type" : "codeVoice"
            },
            {
              "text" : " ends,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and also ensures that ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " is available",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the next time the ",
              "type" : "text"
            },
            {
              "code" : "incrementer",
              "type" : "codeVoice"
            },
            {
              "text" : " function is called.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "As an optimization,",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "Swift may instead capture and store a ",
                  "type" : "text"
                },
                {
                  "inlineContent" : [
                    {
                      "text" : "copy",
                      "type" : "text"
                    }
                  ],
                  "type" : "emphasis"
                },
                {
                  "text" : " of a value",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "if that value isn’t mutated by a closure,",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "and if the value isn’t mutated after the closure is created.Swift also handles all memory management involved in disposing of",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "variables when they’re no longer needed.",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here’s an example of ",
              "type" : "text"
            },
            {
              "code" : "makeIncrementer",
              "type" : "codeVoice"
            },
            {
              "text" : " in action:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let incrementByTen = makeIncrementer(forIncrement: 10)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This example sets a constant called ",
              "type" : "text"
            },
            {
              "code" : "incrementByTen",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to refer to an incrementer function that adds ",
              "type" : "text"
            },
            {
              "code" : "10",
              "type" : "codeVoice"
            },
            {
              "text" : " to",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "its ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " variable each time it’s called.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Calling the function multiple times shows this behavior in action:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "incrementByTen()",
            "\/\/ returns a value of 10",
            "incrementByTen()",
            "\/\/ returns a value of 20",
            "incrementByTen()",
            "\/\/ returns a value of 30"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "If you create a second incrementer,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it will have its own stored reference to a new, separate ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " variable:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let incrementBySeven = makeIncrementer(forIncrement: 7)",
            "incrementBySeven()",
            "\/\/ returns a value of 7"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Calling the original incrementer (",
              "type" : "text"
            },
            {
              "code" : "incrementByTen",
              "type" : "codeVoice"
            },
            {
              "text" : ") again",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "continues to increment its own ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " variable,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and doesn’t affect the variable captured by ",
              "type" : "text"
            },
            {
              "code" : "incrementBySeven",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "incrementByTen()",
            "\/\/ returns a value of 40"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "If you assign a closure to a property of a class instance,",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "and the closure captures that instance by referring to the instance or its members,",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "you will create a strong reference cycle between the closure and the instance.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "Swift uses ",
                  "type" : "text"
                },
                {
                  "inlineContent" : [
                    {
                      "text" : "capture lists",
                      "type" : "text"
                    }
                  ],
                  "type" : "emphasis"
                },
                {
                  "text" : " to break these strong reference cycles.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "For more information, see ",
                  "type" : "text"
                },
                {
                  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures",
                  "isActive" : true,
                  "type" : "reference"
                },
                {
                  "text" : ".",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "anchor" : "Closures-Are-Reference-Types",
          "level" : 2,
          "text" : "Closures Are Reference Types",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "In the example above,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "incrementBySeven",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "incrementByTen",
              "type" : "codeVoice"
            },
            {
              "text" : " are constants,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but the closures these constants refer to are still able to increment",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "runningTotal",
              "type" : "codeVoice"
            },
            {
              "text" : " variables that they have captured.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This is because functions and closures are ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "reference types",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Whenever you assign a function or a closure to a constant or a variable,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you are actually setting that constant or variable to be",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "a ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "reference",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " to the function or closure.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In the example above,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it’s the choice of closure that ",
              "type" : "text"
            },
            {
              "code" : "incrementByTen",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "refers to",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " that’s constant,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and not the contents of the closure itself.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "This also means that if you assign a closure to two different constants or variables,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "both of those constants or variables refer to the same closure.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let alsoIncrementByTen = incrementByTen",
            "alsoIncrementByTen()",
            "\/\/ returns a value of 50",
            "",
            "incrementByTen()",
            "\/\/ returns a value of 60"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example above shows that calling ",
              "type" : "text"
            },
            {
              "code" : "alsoIncrementByTen",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is the same as calling ",
              "type" : "text"
            },
            {
              "code" : "incrementByTen",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because both of them refer to the same closure,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "they both increment and return the same running total.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Escaping-Closures",
          "level" : 2,
          "text" : "Escaping Closures",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "A closure is said to ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "escape",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " a function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when the closure is passed as an argument to the function,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but is called after the function returns.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "When you declare a function that takes a closure as one of its parameters,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you can write ",
              "type" : "text"
            },
            {
              "code" : "@escaping",
              "type" : "codeVoice"
            },
            {
              "text" : " before the parameter’s type",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to indicate that the closure is allowed to escape.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "One way that a closure can escape",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is by being stored in a variable that’s defined outside the function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "As an example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "many functions that start an asynchronous operation",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "take a closure argument as a completion handler.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The function returns after it starts the operation,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but the closure isn’t called until the operation is completed —",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the closure needs to escape, to be called later.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "var completionHandlers: [() -> Void] = []",
            "func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {",
            "    completionHandlers.append(completionHandler)",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "someFunctionWithEscapingClosure(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function takes a closure as its argument",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and adds it to an array that’s declared outside the function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "If you didn’t mark the parameter of this function with ",
              "type" : "text"
            },
            {
              "code" : "@escaping",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you would get a compile-time error.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "An escaping closure that refers to ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "needs special consideration if ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " refers to an instance of a class.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Capturing ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " in an escaping closure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "makes it easy to accidentally create a strong reference cycle.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For information about reference cycles,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "see ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Normally, a closure captures variables implicitly",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by using them in the body of the closure,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but in this case you need to be explicit.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "If you want to capture ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "write ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " explicitly when you use it,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or include ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " in the closure’s capture list.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Writing ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " explicitly lets you express your intent,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and reminds you to confirm that there isn’t a reference cycle.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example, in the code below,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the closure passed to ",
              "type" : "text"
            },
            {
              "code" : "someFunctionWithEscapingClosure(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "refers to ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " explicitly.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In contrast, the closure passed to ",
              "type" : "text"
            },
            {
              "code" : "someFunctionWithNonescapingClosure(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "is a nonescaping closure, which means it can refer to ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " implicitly.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func someFunctionWithNonescapingClosure(closure: () -> Void) {",
            "    closure()",
            "}",
            "",
            "class SomeClass {",
            "    var x = 10",
            "    func doSomething() {",
            "        someFunctionWithEscapingClosure { self.x = 100 }",
            "        someFunctionWithNonescapingClosure { x = 200 }",
            "    }",
            "}",
            "",
            "let instance = SomeClass()",
            "instance.doSomething()",
            "print(instance.x)",
            "\/\/ Prints \"200\"",
            "",
            "completionHandlers.first?()",
            "print(instance.x)",
            "\/\/ Prints \"100\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here’s a version of ",
              "type" : "text"
            },
            {
              "code" : "doSomething()",
              "type" : "codeVoice"
            },
            {
              "text" : " that captures ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by including it in the closure’s capture list,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and then refers to ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " implicitly:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "class SomeOtherClass {",
            "    var x = 10",
            "    func doSomething() {",
            "        someFunctionWithEscapingClosure { [self] in x = 100 }",
            "        someFunctionWithNonescapingClosure { x = 200 }",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "If ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " is an instance of a structure or an enumeration,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you can always refer to ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " implicitly.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "However,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "an escaping closure can’t capture a mutable reference to ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " is an instance of a structure or an enumeration.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Structures and enumerations don’t allow shared mutability,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as discussed in ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct SomeStruct {",
            "    var x = 10",
            "    mutating func doSomething() {",
            "        someFunctionWithNonescapingClosure { x = 200 }  \/\/ Ok",
            "        someFunctionWithEscapingClosure { x = 100 }     \/\/ Error",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The call to the ",
              "type" : "text"
            },
            {
              "code" : "someFunctionWithEscapingClosure",
              "type" : "codeVoice"
            },
            {
              "text" : " function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in the example above is an error",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because it’s inside a mutating method,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " is mutable.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "That violates the rule that escaping closures can’t capture",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "a mutable reference to ",
              "type" : "text"
            },
            {
              "code" : "self",
              "type" : "codeVoice"
            },
            {
              "text" : " for structures.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Autoclosures",
          "level" : 2,
          "text" : "Autoclosures",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "An ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "autoclosure",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " is a closure that’s automatically created",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to wrap an expression that’s being passed as an argument to a function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It doesn’t take any arguments,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and when it’s called, it returns the value",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "of the expression that’s wrapped inside of it.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This syntactic convenience lets you omit braces around a function’s parameter",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by writing a normal expression instead of an explicit closure.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "It’s common to ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "call",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " functions that take autoclosures,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but it’s not common to ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "implement",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " that kind of function.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "assert(condition:message:file:line:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "takes an autoclosure for its ",
              "type" : "text"
            },
            {
              "code" : "condition",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "message",
              "type" : "codeVoice"
            },
            {
              "text" : " parameters;",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "its ",
              "type" : "text"
            },
            {
              "code" : "condition",
              "type" : "codeVoice"
            },
            {
              "text" : " parameter is evaluated only in debug builds",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and its ",
              "type" : "text"
            },
            {
              "code" : "message",
              "type" : "codeVoice"
            },
            {
              "text" : " parameter is evaluated only if ",
              "type" : "text"
            },
            {
              "code" : "condition",
              "type" : "codeVoice"
            },
            {
              "text" : " is ",
              "type" : "text"
            },
            {
              "code" : "false",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "An autoclosure lets you delay evaluation,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because the code inside isn’t run until you call the closure.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Delaying evaluation is useful for code",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that has side effects or is computationally expensive,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because it lets you control when that code is evaluated.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The code below shows how a closure delays evaluation.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "var customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]",
            "print(customersInLine.count)",
            "\/\/ Prints \"5\"",
            "",
            "let customerProvider = { customersInLine.remove(at: 0) }",
            "print(customersInLine.count)",
            "\/\/ Prints \"5\"",
            "",
            "print(\"Now serving \\(customerProvider())!\")",
            "\/\/ Prints \"Now serving Chris!\"",
            "print(customersInLine.count)",
            "\/\/ Prints \"4\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Even though the first element of the ",
              "type" : "text"
            },
            {
              "code" : "customersInLine",
              "type" : "codeVoice"
            },
            {
              "text" : " array is removed",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by the code inside the closure,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the array element isn’t removed until the closure is actually called.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "If the closure is never called,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the expression inside the closure is never evaluated,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which means the array element is never removed.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Note that the type of ",
              "type" : "text"
            },
            {
              "code" : "customerProvider",
              "type" : "codeVoice"
            },
            {
              "text" : " isn’t ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but ",
              "type" : "text"
            },
            {
              "code" : "() -> String",
              "type" : "codeVoice"
            },
            {
              "text" : " —",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "a function with no parameters that returns a string.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You get the same behavior of delayed evaluation",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when you pass a closure as an argument to a function.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "\/\/ customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]",
            "func serve(customer customerProvider: () -> String) {",
            "    print(\"Now serving \\(customerProvider())!\")",
            "}",
            "serve(customer: { customersInLine.remove(at: 0) } )",
            "\/\/ Prints \"Now serving Alex!\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "serve(customer:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function in the listing above",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "takes an explicit closure that returns a customer’s name.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The version of ",
              "type" : "text"
            },
            {
              "code" : "serve(customer:)",
              "type" : "codeVoice"
            },
            {
              "text" : " below",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "performs the same operation but, instead of taking an explicit closure,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it takes an autoclosure",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by marking its parameter’s type with the ",
              "type" : "text"
            },
            {
              "code" : "@autoclosure",
              "type" : "codeVoice"
            },
            {
              "text" : " attribute.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Now you can call the function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as if it took a ",
              "type" : "text"
            },
            {
              "code" : "String",
              "type" : "codeVoice"
            },
            {
              "text" : " argument instead of a closure.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The argument is automatically converted to a closure,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because the ",
              "type" : "text"
            },
            {
              "code" : "customerProvider",
              "type" : "codeVoice"
            },
            {
              "text" : " parameter’s type is marked",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with the ",
              "type" : "text"
            },
            {
              "code" : "@autoclosure",
              "type" : "codeVoice"
            },
            {
              "text" : " attribute.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "\/\/ customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]",
            "func serve(customer customerProvider: @autoclosure () -> String) {",
            "    print(\"Now serving \\(customerProvider())!\")",
            "}",
            "serve(customer: customersInLine.remove(at: 0))",
            "\/\/ Prints \"Now serving Ewa!\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "Overusing autoclosures can make your code hard to understand.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "The context and function name should make it clear",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "that evaluation is being deferred.",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "inlineContent" : [
            {
              "text" : "If you want an autoclosure that’s allowed to escape,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "use both the ",
              "type" : "text"
            },
            {
              "code" : "@autoclosure",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "@escaping",
              "type" : "codeVoice"
            },
            {
              "text" : " attributes.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "@escaping",
              "type" : "codeVoice"
            },
            {
              "text" : " attribute is described above in ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "\/\/ customersInLine is [\"Barry\", \"Daniella\"]",
            "var customerProviders: [() -> String] = []",
            "func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {",
            "    customerProviders.append(customerProvider)",
            "}",
            "collectCustomerProviders(customersInLine.remove(at: 0))",
            "collectCustomerProviders(customersInLine.remove(at: 0))",
            "",
            "print(\"Collected \\(customerProviders.count) closures.\")",
            "\/\/ Prints \"Collected 2 closures.\"",
            "for customerProvider in customerProviders {",
            "    print(\"Now serving \\(customerProvider())!\")",
            "}",
            "\/\/ Prints \"Now serving Barry!\"",
            "\/\/ Prints \"Now serving Daniella!\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "In the code above,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "instead of calling the closure passed to it",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as its ",
              "type" : "text"
            },
            {
              "code" : "customerProvider",
              "type" : "codeVoice"
            },
            {
              "text" : " argument,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "collectCustomerProviders(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "appends the closure to the ",
              "type" : "text"
            },
            {
              "code" : "customerProviders",
              "type" : "codeVoice"
            },
            {
              "text" : " array.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The array is declared outside the scope of the function,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which means the closures in the array can be executed after the function returns.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "As a result,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the value of the ",
              "type" : "text"
            },
            {
              "code" : "customerProvider",
              "type" : "codeVoice"
            },
            {
              "text" : " argument",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "must be allowed to escape the function’s scope.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        }
      ],
      "kind" : "content"
    }
  ],
  "schemaVersion" : {
    "major" : 0,
    "minor" : 3,
    "patch" : 0
  },
  "sections" : [

  ]
, 
"references": {
"doc://org.swift.tspl/documentation/TSPL": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/TSPL",
  "kind" : "article",
  "role" : "collection",
  "title" : "The Swift Programming Language",
  "type" : "topic",
  "url" : "\/documentation\/tspl"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#Operator-Methods": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Operator-Methods",
  "kind" : "section",
  "title" : "Operator Methods",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/advancedoperators#Operator-Methods"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting": {
  "abstract" : [
    {
      "text" : "Model the lifetime of objects and their relationships.",
      "type" : "text"
    }
  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting",
  "kind" : "article",
  "role" : "article",
  "title" : "Automatic Reference Counting",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/automaticreferencecounting"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures",
  "kind" : "section",
  "title" : "Strong Reference Cycles for Closures",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/automaticreferencecounting#Strong-Reference-Cycles-for-Closures"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types",
  "kind" : "section",
  "title" : "Structures and Enumerations Are Value Types",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/classesandstructures#Structures-and-Enumerations-Are-Value-Types"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Capturing-Values": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Capturing-Values",
  "kind" : "section",
  "title" : "Capturing Values",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/closures#Capturing-Values"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Closure-Expression-Syntax": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expression-Syntax",
  "kind" : "section",
  "title" : "Closure Expression Syntax",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/closures#Closure-Expression-Syntax"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Escaping-Closures": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures",
  "kind" : "section",
  "title" : "Escaping Closures",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/closures#Escaping-Closures"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency": {
  "abstract" : [
    {
      "text" : "Perform asynchronous operations.",
      "type" : "text"
    }
  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency",
  "kind" : "article",
  "role" : "article",
  "title" : "Concurrency",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/concurrency"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions": {
  "abstract" : [
    {
      "text" : "Define and call functions, label their arguments, and use their return values.",
      "type" : "text"
    }
  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions",
  "kind" : "article",
  "role" : "article",
  "title" : "Functions",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/functions"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#Function-Types-as-Return-Types": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Function-Types-as-Return-Types",
  "kind" : "section",
  "title" : "Function Types as Return Types",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/functions#Function-Types-as-Return-Types"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#Nested-Functions": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#Nested-Functions",
  "kind" : "section",
  "title" : "Nested Functions",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/functions#Nested-Functions"
}
}
}