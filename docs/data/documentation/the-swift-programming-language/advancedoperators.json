{
  "abstract" : [
    {
      "text" : "Define custom operators, perform bitwise operations, and use builder syntax.",
      "type" : "text"
    }
  ],
  "hierarchy" : {
    "paths" : [
      [
        "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"
      ]
    ]
  },
  "identifier" : {
    "interfaceLanguage" : "swift",
    "url" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"
  },
  "kind" : "article",
  "metadata" : {
    "title" : "Advanced Operators"
  },
  "primaryContentSections" : [
    {
      "content" : [
        {
          "inlineContent" : [
            {
              "text" : "In addition to the operators described in ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift provides several advanced operators that perform more complex value manipulation.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "These include all of the bitwise and bit shifting operators you will be familiar with",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "from C and Objective-C.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Unlike arithmetic operators in C,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "arithmetic operators in Swift don’t overflow by default.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Overflow behavior is trapped and reported as an error.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "To opt in to overflow behavior,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "use Swift’s second set of arithmetic operators that overflow by default,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "such as the overflow addition operator (",
              "type" : "text"
            },
            {
              "code" : "&+",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "All of these overflow operators begin with an ampersand (",
              "type" : "text"
            },
            {
              "code" : "&",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "When you define your own structures, classes, and enumerations,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it can be useful to provide your own implementations of",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the standard Swift operators for these custom types.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift makes it easy to provide tailored implementations of these operators",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and to determine exactly what their behavior should be for each type you create.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You’re not limited to the predefined operators.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift gives you the freedom to define your own custom",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "infix, prefix, postfix, and assignment operators,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with custom precedence and associativity values.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "These operators can be used and adopted in your code like any of the predefined operators,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and you can even extend existing types to support the custom operators you define.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Bitwise-Operators",
          "level" : 2,
          "text" : "Bitwise Operators",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "inlineContent" : [
                {
                  "text" : "Bitwise operators",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " enable you to manipulate",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the individual raw data bits within a data structure.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "They’re often used in low-level programming,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "such as graphics programming and device driver creation.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Bitwise operators can also be useful when you work with raw data from external sources,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "such as encoding and decoding data for communication over a custom protocol.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Swift supports all of the bitwise operators found in C, as described below.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Bitwise-NOT-Operator",
          "level" : 3,
          "text" : "Bitwise NOT Operator",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "bitwise NOT operator",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " (",
              "type" : "text"
            },
            {
              "code" : "~",
              "type" : "codeVoice"
            },
            {
              "text" : ") inverts all bits in a number:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitwiseNOT",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The bitwise NOT operator is a prefix operator,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and appears immediately before the value it operates on,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "without any white space:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let initialBits: UInt8 = 0b00001111",
            "let invertedBits = ~initialBits  \/\/ equals 11110000"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "code" : "UInt8",
              "type" : "codeVoice"
            },
            {
              "text" : " integers have eight bits",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and can store any value between ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "255",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This example initializes a ",
              "type" : "text"
            },
            {
              "code" : "UInt8",
              "type" : "codeVoice"
            },
            {
              "text" : " integer with the binary value ",
              "type" : "text"
            },
            {
              "code" : "00001111",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which has its first four bits set to ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and its second four bits set to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This is equivalent to a decimal value of ",
              "type" : "text"
            },
            {
              "code" : "15",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The bitwise NOT operator is then used to create a new constant called ",
              "type" : "text"
            },
            {
              "code" : "invertedBits",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which is equal to ",
              "type" : "text"
            },
            {
              "code" : "initialBits",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but with all of the bits inverted.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Zeros become ones, and ones become zeros.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The value of ",
              "type" : "text"
            },
            {
              "code" : "invertedBits",
              "type" : "codeVoice"
            },
            {
              "text" : " is ",
              "type" : "text"
            },
            {
              "code" : "11110000",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which is equal to an unsigned decimal value of ",
              "type" : "text"
            },
            {
              "code" : "240",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Bitwise-AND-Operator",
          "level" : 3,
          "text" : "Bitwise AND Operator",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "bitwise AND operator",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " (",
              "type" : "text"
            },
            {
              "code" : "&",
              "type" : "codeVoice"
            },
            {
              "text" : ") combines the bits of two numbers.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It returns a new number whose bits are set to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "only if the bits were equal to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " in ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "both",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " input numbers:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitwiseAND",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In the example below,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the values of ",
              "type" : "text"
            },
            {
              "code" : "firstSixBits",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "lastSixBits",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "both have four middle bits equal to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The bitwise AND operator combines them to make the number ",
              "type" : "text"
            },
            {
              "code" : "00111100",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which is equal to an unsigned decimal value of ",
              "type" : "text"
            },
            {
              "code" : "60",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let firstSixBits: UInt8 = 0b11111100",
            "let lastSixBits: UInt8  = 0b00111111",
            "let middleFourBits = firstSixBits & lastSixBits  \/\/ equals 00111100"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "anchor" : "Bitwise-OR-Operator",
          "level" : 3,
          "text" : "Bitwise OR Operator",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "bitwise OR operator",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " (",
              "type" : "text"
            },
            {
              "code" : "|",
              "type" : "codeVoice"
            },
            {
              "text" : ") compares the bits of two numbers.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The operator returns a new number whose bits are set to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "if the bits are equal to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " in ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "either",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " input number:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitwiseOR",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In the example below,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the values of ",
              "type" : "text"
            },
            {
              "code" : "someBits",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "moreBits",
              "type" : "codeVoice"
            },
            {
              "text" : " have different bits set to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The bitwise OR operator combines them to make the number ",
              "type" : "text"
            },
            {
              "code" : "11111110",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which equals an unsigned decimal of ",
              "type" : "text"
            },
            {
              "code" : "254",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let someBits: UInt8 = 0b10110010",
            "let moreBits: UInt8 = 0b01011110",
            "let combinedbits = someBits | moreBits  \/\/ equals 11111110"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "anchor" : "Bitwise-XOR-Operator",
          "level" : 3,
          "text" : "Bitwise XOR Operator",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "bitwise XOR operator",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ", or “exclusive OR operator” (",
              "type" : "text"
            },
            {
              "code" : "^",
              "type" : "codeVoice"
            },
            {
              "text" : "),",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "compares the bits of two numbers.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The operator returns a new number whose bits are set to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "where the input bits are different",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and are set to ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : " where the input bits are the same:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitwiseXOR",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In the example below,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the values of ",
              "type" : "text"
            },
            {
              "code" : "firstBits",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "otherBits",
              "type" : "codeVoice"
            },
            {
              "text" : " each have a bit set to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in a location that the other does not.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The bitwise XOR operator sets both of these bits to ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " in its output value.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "All of the other bits in ",
              "type" : "text"
            },
            {
              "code" : "firstBits",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "otherBits",
              "type" : "codeVoice"
            },
            {
              "text" : " match",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and are set to ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : " in the output value:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let firstBits: UInt8 = 0b00010100",
            "let otherBits: UInt8 = 0b00000101",
            "let outputBits = firstBits ^ otherBits  \/\/ equals 00010001"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "anchor" : "Bitwise-Left-and-Right-Shift-Operators",
          "level" : 3,
          "text" : "Bitwise Left and Right Shift Operators",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "bitwise left shift operator",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " (",
              "type" : "text"
            },
            {
              "code" : "<<",
              "type" : "codeVoice"
            },
            {
              "text" : ")",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "bitwise right shift operator",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " (",
              "type" : "text"
            },
            {
              "code" : ">>",
              "type" : "codeVoice"
            },
            {
              "text" : ")",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "move all bits in a number to the left or the right by a certain number of places,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "according to the rules defined below.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Bitwise left and right shifts have the effect of",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "multiplying or dividing an integer by a factor of two.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Shifting an integer’s bits to the left by one position doubles its value,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "whereas shifting it to the right by one position halves its value.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Shifting-Behavior-for-Unsigned-Integers",
          "level" : 4,
          "text" : "Shifting Behavior for Unsigned Integers",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The bit-shifting behavior for unsigned integers is as follows:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Existing bits are moved to the left or right by the requested number of places.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Any bits that are moved beyond the bounds of the integer’s storage are discarded.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Zeros are inserted in the spaces left behind",
                      "type" : "text"
                    },
                    {
                      "text" : " ",
                      "type" : "text"
                    },
                    {
                      "text" : "after the original bits are moved to the left or right.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            }
          ],
          "type" : "orderedList"
        },
        {
          "inlineContent" : [
            {
              "text" : "This approach is known as a ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "logical shift",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The illustration below shows the results of ",
              "type" : "text"
            },
            {
              "code" : "11111111 << 1",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "(which is ",
              "type" : "text"
            },
            {
              "code" : "11111111",
              "type" : "codeVoice"
            },
            {
              "text" : " shifted to the left by ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " place),",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and ",
              "type" : "text"
            },
            {
              "code" : "11111111 >> 1",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "(which is ",
              "type" : "text"
            },
            {
              "code" : "11111111",
              "type" : "codeVoice"
            },
            {
              "text" : " shifted to the right by ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " place).",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Blue numbers are shifted,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "gray numbers are discarded,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and orange zeros are inserted:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitshiftUnsigned",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here’s how bit shifting looks in Swift code:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let shiftBits: UInt8 = 4   \/\/ 00000100 in binary",
            "shiftBits << 1             \/\/ 00001000",
            "shiftBits << 2             \/\/ 00010000",
            "shiftBits << 5             \/\/ 10000000",
            "shiftBits << 6             \/\/ 00000000",
            "shiftBits >> 2             \/\/ 00000001"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can use bit shifting to encode and decode values within other data types:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let pink: UInt32 = 0xCC6699",
            "let redComponent = (pink & 0xFF0000) >> 16    \/\/ redComponent is 0xCC, or 204",
            "let greenComponent = (pink & 0x00FF00) >> 8   \/\/ greenComponent is 0x66, or 102",
            "let blueComponent = pink & 0x0000FF           \/\/ blueComponent is 0x99, or 153"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This example uses a ",
              "type" : "text"
            },
            {
              "code" : "UInt32",
              "type" : "codeVoice"
            },
            {
              "text" : " constant called ",
              "type" : "text"
            },
            {
              "code" : "pink",
              "type" : "codeVoice"
            },
            {
              "text" : " to store a",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Cascading Style Sheets color value for the color pink.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The CSS color value ",
              "type" : "text"
            },
            {
              "code" : "#CC6699",
              "type" : "codeVoice"
            },
            {
              "text" : " is written as",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "0xCC6699",
              "type" : "codeVoice"
            },
            {
              "text" : " in Swift’s hexadecimal number representation.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This color is then decomposed into its",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "red (",
              "type" : "text"
            },
            {
              "code" : "CC",
              "type" : "codeVoice"
            },
            {
              "text" : "), green (",
              "type" : "text"
            },
            {
              "code" : "66",
              "type" : "codeVoice"
            },
            {
              "text" : "), and blue (",
              "type" : "text"
            },
            {
              "code" : "99",
              "type" : "codeVoice"
            },
            {
              "text" : ") components",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by the bitwise AND operator (",
              "type" : "text"
            },
            {
              "code" : "&",
              "type" : "codeVoice"
            },
            {
              "text" : ") and the bitwise right shift operator (",
              "type" : "text"
            },
            {
              "code" : ">>",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The red component is obtained by performing a bitwise AND",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "between the numbers ",
              "type" : "text"
            },
            {
              "code" : "0xCC6699",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "0xFF0000",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The zeros in ",
              "type" : "text"
            },
            {
              "code" : "0xFF0000",
              "type" : "codeVoice"
            },
            {
              "text" : " effectively “mask” the second and third bytes of ",
              "type" : "text"
            },
            {
              "code" : "0xCC6699",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "causing the ",
              "type" : "text"
            },
            {
              "code" : "6699",
              "type" : "codeVoice"
            },
            {
              "text" : " to be ignored and leaving ",
              "type" : "text"
            },
            {
              "code" : "0xCC0000",
              "type" : "codeVoice"
            },
            {
              "text" : " as the result.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "This number is then shifted 16 places to the right (",
              "type" : "text"
            },
            {
              "code" : ">> 16",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Each pair of characters in a hexadecimal number uses 8 bits,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so a move 16 places to the right will convert ",
              "type" : "text"
            },
            {
              "code" : "0xCC0000",
              "type" : "codeVoice"
            },
            {
              "text" : " into ",
              "type" : "text"
            },
            {
              "code" : "0x0000CC",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This is the same as ",
              "type" : "text"
            },
            {
              "code" : "0xCC",
              "type" : "codeVoice"
            },
            {
              "text" : ", which has a decimal value of ",
              "type" : "text"
            },
            {
              "code" : "204",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Similarly, the green component is obtained by performing a bitwise AND",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "between the numbers ",
              "type" : "text"
            },
            {
              "code" : "0xCC6699",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "0x00FF00",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which gives an output value of ",
              "type" : "text"
            },
            {
              "code" : "0x006600",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This output value is then shifted eight places to the right,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "giving a value of ",
              "type" : "text"
            },
            {
              "code" : "0x66",
              "type" : "codeVoice"
            },
            {
              "text" : ", which has a decimal value of ",
              "type" : "text"
            },
            {
              "code" : "102",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Finally, the blue component is obtained by performing a bitwise AND",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "between the numbers ",
              "type" : "text"
            },
            {
              "code" : "0xCC6699",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "0x0000FF",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which gives an output value of ",
              "type" : "text"
            },
            {
              "code" : "0x000099",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because ",
              "type" : "text"
            },
            {
              "code" : "0x000099",
              "type" : "codeVoice"
            },
            {
              "text" : " already equals ",
              "type" : "text"
            },
            {
              "code" : "0x99",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which has a decimal value of ",
              "type" : "text"
            },
            {
              "code" : "153",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "this value is used without shifting it to the right,",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Shifting-Behavior-for-Signed-Integers",
          "level" : 4,
          "text" : "Shifting Behavior for Signed Integers",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The shifting behavior is more complex for signed integers than for unsigned integers,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because of the way signed integers are represented in binary.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "(The examples below are based on 8-bit signed integers for simplicity,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but the same principles apply for signed integers of any size.)",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Signed integers use their first bit (known as the ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "sign bit",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ")",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to indicate whether the integer is positive or negative.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "A sign bit of ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : " means positive, and a sign bit of ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " means negative.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The remaining bits (known as the ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "value bits",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ") store the actual value.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Positive numbers are stored in exactly the same way as for unsigned integers,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "counting upwards from ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Here’s how the bits inside an ",
              "type" : "text"
            },
            {
              "code" : "Int8",
              "type" : "codeVoice"
            },
            {
              "text" : " look for the number ",
              "type" : "text"
            },
            {
              "code" : "4",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitshiftSignedFour",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The sign bit is ",
              "type" : "text"
            },
            {
              "code" : "0",
              "type" : "codeVoice"
            },
            {
              "text" : " (meaning “positive”),",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the seven value bits are just the number ",
              "type" : "text"
            },
            {
              "code" : "4",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "written in binary notation.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Negative numbers, however, are stored differently.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "They’re stored by subtracting their absolute value from ",
              "type" : "text"
            },
            {
              "code" : "2",
              "type" : "codeVoice"
            },
            {
              "text" : " to the power of ",
              "type" : "text"
            },
            {
              "code" : "n",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "where ",
              "type" : "text"
            },
            {
              "code" : "n",
              "type" : "codeVoice"
            },
            {
              "text" : " is the number of value bits.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "An eight-bit number has seven value bits,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so this means ",
              "type" : "text"
            },
            {
              "code" : "2",
              "type" : "codeVoice"
            },
            {
              "text" : " to the power of ",
              "type" : "text"
            },
            {
              "code" : "7",
              "type" : "codeVoice"
            },
            {
              "text" : ", or ",
              "type" : "text"
            },
            {
              "code" : "128",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here’s how the bits inside an ",
              "type" : "text"
            },
            {
              "code" : "Int8",
              "type" : "codeVoice"
            },
            {
              "text" : " look for the number ",
              "type" : "text"
            },
            {
              "code" : "-4",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitshiftSignedMinusFour",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "This time, the sign bit is ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " (meaning “negative”),",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the seven value bits have a binary value of ",
              "type" : "text"
            },
            {
              "code" : "124",
              "type" : "codeVoice"
            },
            {
              "text" : " (which is ",
              "type" : "text"
            },
            {
              "code" : "128 - 4",
              "type" : "codeVoice"
            },
            {
              "text" : "):",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitshiftSignedMinusFourValue",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "This encoding for negative numbers is known as a ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "two’s complement",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " representation.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It may seem an unusual way to represent negative numbers,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but it has several advantages.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "First, you can add ",
              "type" : "text"
            },
            {
              "code" : "-1",
              "type" : "codeVoice"
            },
            {
              "text" : " to ",
              "type" : "text"
            },
            {
              "code" : "-4",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "simply by performing a standard binary addition of all eight bits",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "(including the sign bit),",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and discarding anything that doesn’t fit in the eight bits once you’re done:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitshiftSignedAddition",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Second, the two’s complement representation also lets you",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "shift the bits of negative numbers to the left and right like positive numbers,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and still end up doubling them for every shift you make to the left,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or halving them for every shift you make to the right.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "To achieve this, an extra rule is used when signed integers are shifted to the right:",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "When you shift signed integers to the right,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "apply the same rules as for unsigned integers,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "but fill any empty bits on the left with the ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "sign bit",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "rather than with a zero.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "bitshiftSigned",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "This action ensures that signed integers have the same sign after they’re shifted to the right,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and is known as an ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "arithmetic shift",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Because of the special way that positive and negative numbers are stored,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "shifting either of them to the right moves them closer to zero.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Keeping the sign bit the same during this shift means that",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "negative integers remain negative as their value moves closer to zero.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Overflow-Operators",
          "level" : 2,
          "text" : "Overflow Operators",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "If you try to insert a number into an integer constant or variable",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that can’t hold that value,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by default Swift reports an error rather than allowing an invalid value to be created.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This behavior gives extra safety when you work with numbers that are too large or too small.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "For example, the ",
              "type" : "text"
            },
            {
              "code" : "Int16",
              "type" : "codeVoice"
            },
            {
              "text" : " integer type can hold",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "any signed integer between ",
              "type" : "text"
            },
            {
              "code" : "-32768",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "32767",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Trying to set an ",
              "type" : "text"
            },
            {
              "code" : "Int16",
              "type" : "codeVoice"
            },
            {
              "text" : " constant or variable to a number outside of this range",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "causes an error:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "var potentialOverflow = Int16.max",
            "\/\/ potentialOverflow equals 32767, which is the maximum value an Int16 can hold",
            "potentialOverflow += 1",
            "\/\/ this causes an error"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Providing error handling when values get too large or too small",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "gives you much more flexibility when coding for boundary value conditions.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "However, when you specifically want an overflow condition",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to truncate the number of available bits,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you can opt in to this behavior rather than triggering an error.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift provides three arithmetic ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "overflow operators",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " that opt in to",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the overflow behavior for integer calculations.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "These operators all begin with an ampersand (",
              "type" : "text"
            },
            {
              "code" : "&",
              "type" : "codeVoice"
            },
            {
              "text" : "):",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Overflow addition (",
                      "type" : "text"
                    },
                    {
                      "code" : "&+",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : ")",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Overflow subtraction (",
                      "type" : "text"
                    },
                    {
                      "code" : "&-",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : ")",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Overflow multiplication (",
                      "type" : "text"
                    },
                    {
                      "code" : "&*",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : ")",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            }
          ],
          "type" : "unorderedList"
        },
        {
          "anchor" : "Value-Overflow",
          "level" : 3,
          "text" : "Value Overflow",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Numbers can overflow in both the positive and negative direction.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Here’s an example of what happens when",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "an unsigned integer is allowed to overflow in the positive direction,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "using the overflow addition operator (",
              "type" : "text"
            },
            {
              "code" : "&+",
              "type" : "codeVoice"
            },
            {
              "text" : "):",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "var unsignedOverflow = UInt8.max",
            "\/\/ unsignedOverflow equals 255, which is the maximum value a UInt8 can hold",
            "unsignedOverflow = unsignedOverflow &+ 1",
            "\/\/ unsignedOverflow is now equal to 0"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The variable ",
              "type" : "text"
            },
            {
              "code" : "unsignedOverflow",
              "type" : "codeVoice"
            },
            {
              "text" : " is initialized with the maximum value a ",
              "type" : "text"
            },
            {
              "code" : "UInt8",
              "type" : "codeVoice"
            },
            {
              "text" : " can hold",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "(",
              "type" : "text"
            },
            {
              "code" : "255",
              "type" : "codeVoice"
            },
            {
              "text" : ", or ",
              "type" : "text"
            },
            {
              "code" : "11111111",
              "type" : "codeVoice"
            },
            {
              "text" : " in binary).",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It’s then incremented by ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " using the overflow addition operator (",
              "type" : "text"
            },
            {
              "code" : "&+",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This pushes its binary representation just over the size that a ",
              "type" : "text"
            },
            {
              "code" : "UInt8",
              "type" : "codeVoice"
            },
            {
              "text" : " can hold,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "causing it to overflow beyond its bounds,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as shown in the diagram below.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The value that remains within the bounds of the ",
              "type" : "text"
            },
            {
              "code" : "UInt8",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "after the overflow addition is ",
              "type" : "text"
            },
            {
              "code" : "00000000",
              "type" : "codeVoice"
            },
            {
              "text" : ", or zero.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "overflowAddition",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Something similar happens when",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "an unsigned integer is allowed to overflow in the negative direction.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Here’s an example using the overflow subtraction operator (",
              "type" : "text"
            },
            {
              "code" : "&-",
              "type" : "codeVoice"
            },
            {
              "text" : "):",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "var unsignedOverflow = UInt8.min",
            "\/\/ unsignedOverflow equals 0, which is the minimum value a UInt8 can hold",
            "unsignedOverflow = unsignedOverflow &- 1",
            "\/\/ unsignedOverflow is now equal to 255"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The minimum value that a ",
              "type" : "text"
            },
            {
              "code" : "UInt8",
              "type" : "codeVoice"
            },
            {
              "text" : " can hold is zero,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or ",
              "type" : "text"
            },
            {
              "code" : "00000000",
              "type" : "codeVoice"
            },
            {
              "text" : " in binary.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "If you subtract ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " from ",
              "type" : "text"
            },
            {
              "code" : "00000000",
              "type" : "codeVoice"
            },
            {
              "text" : " using the overflow subtraction operator (",
              "type" : "text"
            },
            {
              "code" : "&-",
              "type" : "codeVoice"
            },
            {
              "text" : "),",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the number will overflow and wrap around to ",
              "type" : "text"
            },
            {
              "code" : "11111111",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or ",
              "type" : "text"
            },
            {
              "code" : "255",
              "type" : "codeVoice"
            },
            {
              "text" : " in decimal.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "overflowUnsignedSubtraction",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Overflow also occurs for signed integers.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "All addition and subtraction for signed integers is performed in bitwise fashion,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with the sign bit included as part of the numbers being added or subtracted,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as described in ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "var signedOverflow = Int8.min",
            "\/\/ signedOverflow equals -128, which is the minimum value an Int8 can hold",
            "signedOverflow = signedOverflow &- 1",
            "\/\/ signedOverflow is now equal to 127"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The minimum value that an ",
              "type" : "text"
            },
            {
              "code" : "Int8",
              "type" : "codeVoice"
            },
            {
              "text" : " can hold is ",
              "type" : "text"
            },
            {
              "code" : "-128",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or ",
              "type" : "text"
            },
            {
              "code" : "10000000",
              "type" : "codeVoice"
            },
            {
              "text" : " in binary.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Subtracting ",
              "type" : "text"
            },
            {
              "code" : "1",
              "type" : "codeVoice"
            },
            {
              "text" : " from this binary number with the overflow operator",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "gives a binary value of ",
              "type" : "text"
            },
            {
              "code" : "01111111",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which toggles the sign bit and gives positive ",
              "type" : "text"
            },
            {
              "code" : "127",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the maximum positive value that an ",
              "type" : "text"
            },
            {
              "code" : "Int8",
              "type" : "codeVoice"
            },
            {
              "text" : " can hold.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "overflowSignedSubtraction",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "For both signed and unsigned integers,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "overflow in the positive direction",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "wraps around from the maximum valid integer value back to the minimum,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and overflow in the negative direction",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "wraps around from the minimum value to the maximum.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Precedence-and-Associativity",
          "level" : 2,
          "text" : "Precedence and Associativity",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Operator ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "precedence",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " gives some operators higher priority than others;",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "these operators are applied first.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Operator ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "associativity",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " defines how operators of the same precedence",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "are grouped together —",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "either grouped from the left, or grouped from the right.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Think of it as meaning “they associate with the expression to their left,”",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or “they associate with the expression to their right.”",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "It’s important to consider",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "each operator’s precedence and associativity",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when working out the order in which a compound expression will be calculated.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "operator precedence explains why the following expression equals ",
              "type" : "text"
            },
            {
              "code" : "17",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "2 + 3 % 4 * 5",
            "\/\/ this equals 17"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "If you read strictly from left to right,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you might expect the expression to be calculated as follows:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "code" : "2",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " plus ",
                      "type" : "text"
                    },
                    {
                      "code" : "3",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " equals ",
                      "type" : "text"
                    },
                    {
                      "code" : "5",
                      "type" : "codeVoice"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "code" : "5",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " remainder ",
                      "type" : "text"
                    },
                    {
                      "code" : "4",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " equals ",
                      "type" : "text"
                    },
                    {
                      "code" : "1",
                      "type" : "codeVoice"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "code" : "1",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " times ",
                      "type" : "text"
                    },
                    {
                      "code" : "5",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " equals ",
                      "type" : "text"
                    },
                    {
                      "code" : "5",
                      "type" : "codeVoice"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            }
          ],
          "type" : "unorderedList"
        },
        {
          "inlineContent" : [
            {
              "text" : "However, the actual answer is ",
              "type" : "text"
            },
            {
              "code" : "17",
              "type" : "codeVoice"
            },
            {
              "text" : ", not ",
              "type" : "text"
            },
            {
              "code" : "5",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Higher-precedence operators are evaluated before lower-precedence ones.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In Swift, as in C,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the remainder operator (",
              "type" : "text"
            },
            {
              "code" : "%",
              "type" : "codeVoice"
            },
            {
              "text" : ") and the multiplication operator (",
              "type" : "text"
            },
            {
              "code" : "*",
              "type" : "codeVoice"
            },
            {
              "text" : ")",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "have a higher precedence than the addition operator (",
              "type" : "text"
            },
            {
              "code" : "+",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "As a result, they’re both evaluated before the addition is considered.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "However, remainder and multiplication have the ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "same",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " precedence as each other.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "To work out the exact evaluation order to use,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you also need to consider their associativity.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Remainder and multiplication both associate with the expression to their left.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Think of this as adding implicit parentheses around these parts of the expression,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "starting from their left:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "2 + ((3 % 4) * 5)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "code" : "(3 % 4)",
              "type" : "codeVoice"
            },
            {
              "text" : " is ",
              "type" : "text"
            },
            {
              "code" : "3",
              "type" : "codeVoice"
            },
            {
              "text" : ", so this is equivalent to:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "2 + (3 * 5)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "code" : "(3 * 5)",
              "type" : "codeVoice"
            },
            {
              "text" : " is ",
              "type" : "text"
            },
            {
              "code" : "15",
              "type" : "codeVoice"
            },
            {
              "text" : ", so this is equivalent to:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "2 + 15"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This calculation yields the final answer of ",
              "type" : "text"
            },
            {
              "code" : "17",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "For information about the operators provided by the Swift standard library,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "including a complete list of the operator precedence groups and associativity settings,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "see ",
              "type" : "text"
            },
            {
              "identifier" : "https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "Swift’s operator precedences and associativity rules are simpler and more predictable",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "than those found in C and Objective-C.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "However, this means that they aren’t exactly the same as in C-based languages.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "Be careful to ensure that operator interactions still behave in the way you intend",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "when porting existing code to Swift.",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "anchor" : "Operator-Methods",
          "level" : 2,
          "text" : "Operator Methods",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Classes and structures can provide their own implementations of existing operators.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This is known as ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "overloading",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " the existing operators.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example below shows how to implement",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the arithmetic addition operator (",
              "type" : "text"
            },
            {
              "code" : "+",
              "type" : "codeVoice"
            },
            {
              "text" : ") for a custom structure.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The arithmetic addition operator is a binary operator",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because it operates on two targets",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and it’s an infix operator because it appears between those two targets.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example defines a ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " structure for",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "a two-dimensional position vector ",
              "type" : "text"
            },
            {
              "code" : "(x, y)",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "followed by a definition of an ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "operator method",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to add together instances of the ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " structure:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Vector2D {",
            "    var x = 0.0, y = 0.0",
            "}",
            "",
            "extension Vector2D {",
            "    static func + (left: Vector2D, right: Vector2D) -> Vector2D {",
            "       return Vector2D(x: left.x + right.x, y: left.y + right.y)",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The operator method is defined as a type method on ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with a method name that matches the operator to be overloaded (",
              "type" : "text"
            },
            {
              "code" : "+",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because addition isn’t part of the essential behavior for a vector,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the type method is defined in an extension of ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "rather than in the main structure declaration of ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because the arithmetic addition operator is a binary operator,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "this operator method takes two input parameters of type ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and returns a single output value, also of type ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In this implementation, the input parameters are named ",
              "type" : "text"
            },
            {
              "code" : "left",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "right",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to represent the ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances that will be on",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the left side and right side of the ",
              "type" : "text"
            },
            {
              "code" : "+",
              "type" : "codeVoice"
            },
            {
              "text" : " operator.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The method returns a new ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instance,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "whose ",
              "type" : "text"
            },
            {
              "code" : "x",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "y",
              "type" : "codeVoice"
            },
            {
              "text" : " properties are",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "initialized with the sum of the ",
              "type" : "text"
            },
            {
              "code" : "x",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "y",
              "type" : "codeVoice"
            },
            {
              "text" : " properties from",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the two ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances that are added together.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The type method",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "can be used as an infix operator between existing ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let vector = Vector2D(x: 3.0, y: 1.0)",
            "let anotherVector = Vector2D(x: 2.0, y: 4.0)",
            "let combinedVector = vector + anotherVector",
            "\/\/ combinedVector is a Vector2D instance with values of (5.0, 5.0)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This example adds together the vectors ",
              "type" : "text"
            },
            {
              "code" : "(3.0, 1.0)",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "(2.0, 4.0)",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to make the vector ",
              "type" : "text"
            },
            {
              "code" : "(5.0, 5.0)",
              "type" : "codeVoice"
            },
            {
              "text" : ", as illustrated below.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "identifier" : "vectorAddition",
              "type" : "image"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Prefix-and-Postfix-Operators",
          "level" : 3,
          "text" : "Prefix and Postfix Operators",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example shown above demonstrates a custom implementation of a binary infix operator.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Classes and structures can also provide implementations",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "of the standard ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "unary operators",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Unary operators operate on a single target.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "They’re ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "prefix",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " if they precede their target (such as ",
              "type" : "text"
            },
            {
              "code" : "-a",
              "type" : "codeVoice"
            },
            {
              "text" : ")",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "postfix",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " operators if they follow their target (such as ",
              "type" : "text"
            },
            {
              "code" : "b!",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You implement a prefix or postfix unary operator by writing",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "code" : "prefix",
              "type" : "codeVoice"
            },
            {
              "text" : " or ",
              "type" : "text"
            },
            {
              "code" : "postfix",
              "type" : "codeVoice"
            },
            {
              "text" : " modifier",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "before the ",
              "type" : "text"
            },
            {
              "code" : "func",
              "type" : "codeVoice"
            },
            {
              "text" : " keyword when declaring the operator method:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "extension Vector2D {",
            "    static prefix func - (vector: Vector2D) -> Vector2D {",
            "        return Vector2D(x: -vector.x, y: -vector.y)",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example above implements the unary minus operator",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "(",
              "type" : "text"
            },
            {
              "code" : "-a",
              "type" : "codeVoice"
            },
            {
              "text" : ") for ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The unary minus operator is a prefix operator,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and so this method has to be qualified with the ",
              "type" : "text"
            },
            {
              "code" : "prefix",
              "type" : "codeVoice"
            },
            {
              "text" : " modifier.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "For simple numeric values, the unary minus operator converts",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "positive numbers into their negative equivalent and vice versa.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The corresponding implementation for ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "performs this operation on both the ",
              "type" : "text"
            },
            {
              "code" : "x",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "y",
              "type" : "codeVoice"
            },
            {
              "text" : " properties:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let positive = Vector2D(x: 3.0, y: 4.0)",
            "let negative = -positive",
            "\/\/ negative is a Vector2D instance with values of (-3.0, -4.0)",
            "let alsoPositive = -negative",
            "\/\/ alsoPositive is a Vector2D instance with values of (3.0, 4.0)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "anchor" : "Compound-Assignment-Operators",
          "level" : 3,
          "text" : "Compound Assignment Operators",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "inlineContent" : [
                {
                  "text" : "Compound assignment operators",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " combine assignment (",
              "type" : "text"
            },
            {
              "code" : "=",
              "type" : "codeVoice"
            },
            {
              "text" : ") with another operation.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example, the addition assignment operator (",
              "type" : "text"
            },
            {
              "code" : "+=",
              "type" : "codeVoice"
            },
            {
              "text" : ")",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "combines addition and assignment into a single operation.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "You mark a compound assignment operator’s left input parameter type as ",
              "type" : "text"
            },
            {
              "code" : "inout",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "because the parameter’s value will be modified directly from within the operator method.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example below implements",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "an addition assignment operator method for ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "extension Vector2D {",
            "    static func += (left: inout Vector2D, right: Vector2D) {",
            "        left = left + right",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Because an addition operator was defined earlier,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you don’t need to reimplement the addition process here.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Instead, the addition assignment operator method",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "takes advantage of the existing addition operator method,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and uses it to set the left value to be the left value plus the right value:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "var original = Vector2D(x: 1.0, y: 2.0)",
            "let vectorToAdd = Vector2D(x: 3.0, y: 4.0)",
            "original += vectorToAdd",
            "\/\/ original now has values of (4.0, 6.0)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "It isn’t possible to overload the default",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "assignment operator (",
                  "type" : "text"
                },
                {
                  "code" : "=",
                  "type" : "codeVoice"
                },
                {
                  "text" : ").",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "Only the compound assignment operators can be overloaded.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "Similarly, the ternary conditional operator",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "(",
                  "type" : "text"
                },
                {
                  "code" : "a ? b : c",
                  "type" : "codeVoice"
                },
                {
                  "text" : ") can’t be overloaded.",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "anchor" : "Equivalence-Operators",
          "level" : 3,
          "text" : "Equivalence Operators",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "By default, custom classes and structures don’t have an implementation of",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "equivalence operators",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "known as the ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "equal to",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " operator (",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : ") and ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "not equal to",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " operator (",
              "type" : "text"
            },
            {
              "code" : "!=",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "You usually implement the ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and use the standard library’s default implementation of the ",
              "type" : "text"
            },
            {
              "code" : "!=",
              "type" : "codeVoice"
            },
            {
              "text" : " operator",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that negates the result of the ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "There are two ways to implement the ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator:",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "You can implement it yourself,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "or for many types, you can ask Swift to synthesize",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "an implementation for you.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In both cases,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you add conformance to the standard library’s ",
              "type" : "text"
            },
            {
              "code" : "Equatable",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You provide an implementation of the ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in the same way as you implement other infix operators:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "extension Vector2D: Equatable {",
            "    static func == (left: Vector2D, right: Vector2D) -> Bool {",
            "       return (left.x == right.x) && (left.y == right.y)",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example above implements an ",
              "type" : "text"
            },
            {
              "code" : "==",
              "type" : "codeVoice"
            },
            {
              "text" : " operator",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to check whether two ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances have equivalent values.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "In the context of ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it makes sense to consider “equal” as meaning",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "“both instances have the same ",
              "type" : "text"
            },
            {
              "code" : "x",
              "type" : "codeVoice"
            },
            {
              "text" : " values and ",
              "type" : "text"
            },
            {
              "code" : "y",
              "type" : "codeVoice"
            },
            {
              "text" : " values”,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and so this is the logic used by the operator implementation.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can now use this operator to check whether two ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances are equivalent:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let twoThree = Vector2D(x: 2.0, y: 3.0)",
            "let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)",
            "if twoThree == anotherTwoThree {",
            "    print(\"These two vectors are equivalent.\")",
            "}",
            "\/\/ Prints \"These two vectors are equivalent.\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "In many simple cases, you can ask Swift",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to provide synthesized implementations of the equivalence operators for you,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as described in ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Custom-Operators",
          "level" : 2,
          "text" : "Custom Operators",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can declare and implement your own ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "custom operators",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " in addition to",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the standard operators provided by Swift.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For a list of characters that can be used to define custom operators,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "see ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure#Operators",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "New operators are declared at a global level using the ",
              "type" : "text"
            },
            {
              "code" : "operator",
              "type" : "codeVoice"
            },
            {
              "text" : " keyword,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and are marked with the ",
              "type" : "text"
            },
            {
              "code" : "prefix",
              "type" : "codeVoice"
            },
            {
              "text" : ", ",
              "type" : "text"
            },
            {
              "code" : "infix",
              "type" : "codeVoice"
            },
            {
              "text" : " or ",
              "type" : "text"
            },
            {
              "code" : "postfix",
              "type" : "codeVoice"
            },
            {
              "text" : " modifiers:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "prefix operator +++"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The example above defines a new prefix operator called ",
              "type" : "text"
            },
            {
              "code" : "+++",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "This operator doesn’t have an existing meaning in Swift,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and so it’s given its own custom meaning below in the specific context of",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "working with ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instances. For the purposes of this example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "code" : "+++",
              "type" : "codeVoice"
            },
            {
              "text" : " is treated as a new “prefix doubling” operator.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It doubles the ",
              "type" : "text"
            },
            {
              "code" : "x",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "y",
              "type" : "codeVoice"
            },
            {
              "text" : " values of a ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " instance,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by adding the vector to itself with the addition assignment operator defined earlier.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "To implement the ",
              "type" : "text"
            },
            {
              "code" : "+++",
              "type" : "codeVoice"
            },
            {
              "text" : " operator,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you add a type method called ",
              "type" : "text"
            },
            {
              "code" : "+++",
              "type" : "codeVoice"
            },
            {
              "text" : " to ",
              "type" : "text"
            },
            {
              "code" : "Vector2D",
              "type" : "codeVoice"
            },
            {
              "text" : " as follows:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "extension Vector2D {",
            "    static prefix func +++ (vector: inout Vector2D) -> Vector2D {",
            "        vector += vector",
            "        return vector",
            "    }",
            "}",
            "",
            "var toBeDoubled = Vector2D(x: 1.0, y: 4.0)",
            "let afterDoubling = +++toBeDoubled",
            "\/\/ toBeDoubled now has values of (2.0, 8.0)",
            "\/\/ afterDoubling also has values of (2.0, 8.0)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "anchor" : "Precedence-for-Custom-Infix-Operators",
          "level" : 3,
          "text" : "Precedence for Custom Infix Operators",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Custom infix operators each belong to a precedence group.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "A precedence group specifies an operator’s precedence relative",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to other infix operators, as well as the operator’s associativity.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "See ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Precedence-and-Associativity",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : " for an explanation of",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "how these characteristics affect an infix operator’s interaction",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "with other infix operators.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "A custom infix operator that isn’t explicitly placed into a precedence group is",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "given a default precedence group with a precedence immediately higher",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "than the precedence of the ternary conditional operator.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The following example defines a new custom infix operator called ",
              "type" : "text"
            },
            {
              "code" : "+-",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which belongs to the precedence group ",
              "type" : "text"
            },
            {
              "code" : "AdditionPrecedence",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "infix operator +-: AdditionPrecedence",
            "extension Vector2D {",
            "    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {",
            "        return Vector2D(x: left.x + right.x, y: left.y - right.y)",
            "    }",
            "}",
            "let firstVector = Vector2D(x: 1.0, y: 2.0)",
            "let secondVector = Vector2D(x: 3.0, y: 4.0)",
            "let plusMinusVector = firstVector +- secondVector",
            "\/\/ plusMinusVector is a Vector2D instance with values of (4.0, -2.0)"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This operator adds together the ",
              "type" : "text"
            },
            {
              "code" : "x",
              "type" : "codeVoice"
            },
            {
              "text" : " values of two vectors,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and subtracts the ",
              "type" : "text"
            },
            {
              "code" : "y",
              "type" : "codeVoice"
            },
            {
              "text" : " value of the second vector from the first.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Because it’s in essence an “additive” operator,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "it has been given the same precedence group",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "as additive infix operators such as ",
              "type" : "text"
            },
            {
              "code" : "+",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "-",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For information about the operators provided by the Swift standard library,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "including a complete list of the operator precedence groups and associativity settings,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "see ",
              "type" : "text"
            },
            {
              "identifier" : "https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations",
              "isActive" : true,
              "overridingTitle" : "Operator Declarations",
              "overridingTitleInlineContent" : [
                {
                  "text" : "Operator Declarations",
                  "type" : "text"
                }
              ],
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For more information about precedence groups and to see the syntax for",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "defining your own operators and precedence groups,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "see ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Operator-Declaration",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "content" : [
            {
              "inlineContent" : [
                {
                  "text" : "You don’t specify a precedence when defining a prefix or postfix operator.",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "However, if you apply both a prefix and a postfix operator to the same operand,",
                  "type" : "text"
                },
                {
                  "text" : " ",
                  "type" : "text"
                },
                {
                  "text" : "the postfix operator is applied first.",
                  "type" : "text"
                }
              ],
              "type" : "paragraph"
            }
          ],
          "name" : "Note",
          "style" : "note",
          "type" : "aside"
        },
        {
          "anchor" : "Result-Builders",
          "level" : 2,
          "text" : "Result Builders",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "A ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "result builder",
                  "type" : "text"
                }
              ],
              "type" : "emphasis"
            },
            {
              "text" : " is a type you define",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that adds syntax for creating nested data,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "like a list or tree,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "in a natural, declarative way.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The code that uses the result builder",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "can include ordinary Swift syntax, like ",
              "type" : "text"
            },
            {
              "code" : "if",
              "type" : "codeVoice"
            },
            {
              "text" : "  and ",
              "type" : "text"
            },
            {
              "code" : "for",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to handle conditional or repeated pieces of data.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The code below defines a few types for drawing on a single line",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "using stars and text.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "protocol Drawable {",
            "    func draw() -> String",
            "}",
            "struct Line: Drawable {",
            "    var elements: [Drawable]",
            "    func draw() -> String {",
            "        return elements.map { $0.draw() }.joined(separator: \"\")",
            "    }",
            "}",
            "struct Text: Drawable {",
            "    var content: String",
            "    init(_ content: String) { self.content = content }",
            "    func draw() -> String { return content }",
            "}",
            "struct Space: Drawable {",
            "    func draw() -> String { return \" \" }",
            "}",
            "struct Stars: Drawable {",
            "    var length: Int",
            "    func draw() -> String { return String(repeating: \"*\", count: length) }",
            "}",
            "struct AllCaps: Drawable {",
            "    var content: Drawable",
            "    func draw() -> String { return content.draw().uppercased() }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "Drawable",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol defines the requirement",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "for something that can be drawn, like a line or shape:",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The type must implement a ",
              "type" : "text"
            },
            {
              "code" : "draw()",
              "type" : "codeVoice"
            },
            {
              "text" : " method.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "Line",
              "type" : "codeVoice"
            },
            {
              "text" : " structure represents a single-line drawing,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and it serves the top-level container for most drawings.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "To draw a ",
              "type" : "text"
            },
            {
              "code" : "Line",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "the structure calls ",
              "type" : "text"
            },
            {
              "code" : "draw()",
              "type" : "codeVoice"
            },
            {
              "text" : " on each of the line’s components,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and then concatenates the resulting strings into a single string.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "Text",
              "type" : "codeVoice"
            },
            {
              "text" : " structure wraps a string to make it part of a drawing.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "AllCaps",
              "type" : "codeVoice"
            },
            {
              "text" : " structure wraps and modifies another drawing,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "converting any text in the drawing to uppercase.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "It’s possible to make a drawing with these types",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "by calling their initializers:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let name: String? = \"Ravi Patel\"",
            "let manualDrawing = Line(elements: [",
            "     Stars(length: 3),",
            "     Text(\"Hello\"),",
            "     Space(),",
            "     AllCaps(content: Text((name ?? \"World\") + \"!\")),",
            "     Stars(length: 2),",
            "])",
            "print(manualDrawing.draw())",
            "\/\/ Prints \"***Hello RAVI PATEL!**\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This code works, but it’s a little awkward.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The deeply nested parentheses after ",
              "type" : "text"
            },
            {
              "code" : "AllCaps",
              "type" : "codeVoice"
            },
            {
              "text" : " are hard to read.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The fallback logic to use “World” when ",
              "type" : "text"
            },
            {
              "code" : "name",
              "type" : "codeVoice"
            },
            {
              "text" : " is ",
              "type" : "text"
            },
            {
              "code" : "nil",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "has to be done inline using the ",
              "type" : "text"
            },
            {
              "code" : "??",
              "type" : "codeVoice"
            },
            {
              "text" : " operator,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which would be difficult with anything more complex.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "If you needed to include switches or ",
              "type" : "text"
            },
            {
              "code" : "for",
              "type" : "codeVoice"
            },
            {
              "text" : " loops",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to build up part of the drawing, there’s no way to do that.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "A result builder lets you rewrite code like this",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "so that it looks like normal Swift code.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "To define a result builder,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you write the ",
              "type" : "text"
            },
            {
              "code" : "@resultBuilder",
              "type" : "codeVoice"
            },
            {
              "text" : " attribute on a type declaration.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example, this code defines a result builder called ",
              "type" : "text"
            },
            {
              "code" : "DrawingBuilder",
              "type" : "codeVoice"
            },
            {
              "text" : ",",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which lets you use a declarative syntax to describe a drawing:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "@resultBuilder",
            "struct DrawingBuilder {",
            "    static func buildBlock(_ components: Drawable...) -> Drawable {",
            "        return Line(elements: components)",
            "    }",
            "    static func buildEither(first: Drawable) -> Drawable {",
            "        return first",
            "    }",
            "    static func buildEither(second: Drawable) -> Drawable {",
            "        return second",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "DrawingBuilder",
              "type" : "codeVoice"
            },
            {
              "text" : " structure defines three methods",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "that implement parts of the result builder syntax.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "buildBlock(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method adds support for",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "writing a series of lines in a block of code.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "It combines the components in that block into a ",
              "type" : "text"
            },
            {
              "code" : "Line",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "buildEither(first:)",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "buildEither(second:)",
              "type" : "codeVoice"
            },
            {
              "text" : " methods",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "add support for ",
              "type" : "text"
            },
            {
              "code" : "if",
              "type" : "codeVoice"
            },
            {
              "text" : "-",
              "type" : "text"
            },
            {
              "code" : "else",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can apply the ",
              "type" : "text"
            },
            {
              "code" : "@DrawingBuilder",
              "type" : "codeVoice"
            },
            {
              "text" : " attribute to a function’s parameter,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which turns a closure passed to the function",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "into the value that the result builder creates from that closure.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "func draw(@DrawingBuilder content: () -> Drawable) -> Drawable {",
            "    return content()",
            "}",
            "func caps(@DrawingBuilder content: () -> Drawable) -> Drawable {",
            "    return AllCaps(content: content())",
            "}",
            "",
            "func makeGreeting(for name: String? = nil) -> Drawable {",
            "    let greeting = draw {",
            "        Stars(length: 3)",
            "        Text(\"Hello\")",
            "        Space()",
            "        caps {",
            "            if let name = name {",
            "                Text(name + \"!\")",
            "            } else {",
            "                Text(\"World!\")",
            "            }",
            "        }",
            "        Stars(length: 2)",
            "    }",
            "    return greeting",
            "}",
            "let genericGreeting = makeGreeting()",
            "print(genericGreeting.draw())",
            "\/\/ Prints \"***Hello WORLD!**\"",
            "",
            "let personalGreeting = makeGreeting(for: \"Ravi Patel\")",
            "print(personalGreeting.draw())",
            "\/\/ Prints \"***Hello RAVI PATEL!**\""
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "makeGreeting(for:)",
              "type" : "codeVoice"
            },
            {
              "text" : " function takes a ",
              "type" : "text"
            },
            {
              "code" : "name",
              "type" : "codeVoice"
            },
            {
              "text" : " parameter",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and uses it to draw a personalized greeting.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "draw(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "caps(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " functions",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "both take a single closure as their argument,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "which is marked with the ",
              "type" : "text"
            },
            {
              "code" : "@DrawingBuilder",
              "type" : "codeVoice"
            },
            {
              "text" : " attribute.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "When you call those functions,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "you use the special syntax that ",
              "type" : "text"
            },
            {
              "code" : "DrawingBuilder",
              "type" : "codeVoice"
            },
            {
              "text" : " defines.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift transforms that declarative description of a drawing",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "into a series of calls to the methods on ",
              "type" : "text"
            },
            {
              "code" : "DrawingBuilder",
              "type" : "codeVoice"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "to build up the value that’s passed as the function argument.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "For example,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Swift transforms the call to ",
              "type" : "text"
            },
            {
              "code" : "caps(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " in that example",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "into code like the following:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "let capsDrawing = caps {",
            "    let partialDrawing: Drawable",
            "    if let name = name {",
            "        let text = Text(name + \"!\")",
            "        partialDrawing = DrawingBuilder.buildEither(first: text)",
            "    } else {",
            "        let text = Text(\"World!\")",
            "        partialDrawing = DrawingBuilder.buildEither(second: text)",
            "    }",
            "    return partialDrawing",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Swift transforms the ",
              "type" : "text"
            },
            {
              "code" : "if",
              "type" : "codeVoice"
            },
            {
              "text" : "-",
              "type" : "text"
            },
            {
              "code" : "else",
              "type" : "codeVoice"
            },
            {
              "text" : " block into",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "calls to the ",
              "type" : "text"
            },
            {
              "code" : "buildEither(first:)",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "buildEither(second:)",
              "type" : "codeVoice"
            },
            {
              "text" : " methods.",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "Although you don’t call these methods in your own code,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "showing the result of the transformation",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "makes it easier to see how Swift transforms your code",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "when you use the ",
              "type" : "text"
            },
            {
              "code" : "DrawingBuilder",
              "type" : "codeVoice"
            },
            {
              "text" : " syntax.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "To add support for writing ",
              "type" : "text"
            },
            {
              "code" : "for",
              "type" : "codeVoice"
            },
            {
              "text" : " loops in the special drawing syntax,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "add a ",
              "type" : "text"
            },
            {
              "code" : "buildArray(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "extension DrawingBuilder {",
            "    static func buildArray(_ components: [Drawable]) -> Drawable {",
            "        return Line(elements: components)",
            "    }",
            "}",
            "let manyStars = draw {",
            "    Text(\"Stars:\")",
            "    for length in 1...3 {",
            "        Space()",
            "        Stars(length: length)",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "In the code above, the ",
              "type" : "text"
            },
            {
              "code" : "for",
              "type" : "codeVoice"
            },
            {
              "text" : " loop creates an array of drawings,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "and the ",
              "type" : "text"
            },
            {
              "code" : "buildArray(_:)",
              "type" : "codeVoice"
            },
            {
              "text" : " method turns that array into a ",
              "type" : "text"
            },
            {
              "code" : "Line",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "For a complete list of how Swift transforms builder syntax",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "into calls to the builder type’s methods,",
              "type" : "text"
            },
            {
              "text" : " ",
              "type" : "text"
            },
            {
              "text" : "see ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes#resultBuilder",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        }
      ],
      "kind" : "content"
    }
  ],
  "schemaVersion" : {
    "major" : 0,
    "minor" : 3,
    "patch" : 0
  },
  "sections" : [

  ]
, 
"references": {
"bitshiftSigned": {
  "alt" : null,
  "identifier" : "bitshiftSigned",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitshiftSigned@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitshiftSigned~dark@2x.png"
    }
  ]
},
"bitshiftSignedAddition": {
  "alt" : null,
  "identifier" : "bitshiftSignedAddition",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitshiftSignedAddition@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitshiftSignedAddition~dark@2x.png"
    }
  ]
},
"bitshiftSignedFour": {
  "alt" : null,
  "identifier" : "bitshiftSignedFour",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitshiftSignedFour@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitshiftSignedFour~dark@2x.png"
    }
  ]
},
"bitshiftSignedMinusFour": {
  "alt" : null,
  "identifier" : "bitshiftSignedMinusFour",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitshiftSignedMinusFour@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitshiftSignedMinusFour~dark@2x.png"
    }
  ]
},
"bitshiftSignedMinusFourValue": {
  "alt" : null,
  "identifier" : "bitshiftSignedMinusFourValue",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitshiftSignedMinusFourValue@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitshiftSignedMinusFourValue~dark@2x.png"
    }
  ]
},
"bitshiftUnsigned": {
  "alt" : null,
  "identifier" : "bitshiftUnsigned",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitshiftUnsigned@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitshiftUnsigned~dark@2x.png"
    }
  ]
},
"bitwiseAND": {
  "alt" : null,
  "identifier" : "bitwiseAND",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitwiseAND@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitwiseAND~dark@2x.png"
    }
  ]
},
"bitwiseNOT": {
  "alt" : null,
  "identifier" : "bitwiseNOT",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitwiseNOT@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitwiseNOT~dark@2x.png"
    }
  ]
},
"bitwiseOR": {
  "alt" : null,
  "identifier" : "bitwiseOR",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitwiseOR@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitwiseOR~dark@2x.png"
    }
  ]
},
"bitwiseXOR": {
  "alt" : null,
  "identifier" : "bitwiseXOR",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/bitwiseXOR@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/bitwiseXOR~dark@2x.png"
    }
  ]
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language",
  "kind" : "article",
  "role" : "collection",
  "title" : "The Swift Programming Language",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators",
  "kind" : "section",
  "title" : "Bitwise Left and Right Shift Operators",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/advancedoperators#Bitwise-Left-and-Right-Shift-Operators"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#Precedence-and-Associativity": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Precedence-and-Associativity",
  "kind" : "section",
  "title" : "Precedence and Associativity",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/advancedoperators#Precedence-and-Associativity"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes#resultBuilder": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes#resultBuilder",
  "kind" : "section",
  "title" : "resultBuilder",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/attributes#resultBuilder"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators": {
  "abstract" : [
    {
      "text" : "Perform operations like assignment, arithmetic, and comparison.",
      "type" : "text"
    }
  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators",
  "kind" : "article",
  "role" : "article",
  "title" : "Basic Operators",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/basicoperators"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Operator-Declaration": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Operator-Declaration",
  "kind" : "section",
  "title" : "Operator Declaration",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/declarations#Operator-Declaration"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/LexicalStructure#Operators": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure#Operators",
  "kind" : "section",
  "title" : "Operators",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/lexicalstructure#Operators"
},
"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation": {
  "abstract" : [

  ],
  "identifier" : "doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation",
  "kind" : "section",
  "title" : "Adopting a Protocol Using a Synthesized Implementation",
  "type" : "topic",
  "url" : "\/documentation\/the-swift-programming-language\/protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation"
},
"https://developer.apple.com/documentation/swift/operator_declarations": {
  "identifier" : "https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations",
  "title" : "Operator Declarations",
  "titleInlineContent" : [
    {
      "text" : "Operator Declarations",
      "type" : "text"
    }
  ],
  "type" : "link",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"
},
"overflowAddition": {
  "alt" : null,
  "identifier" : "overflowAddition",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/overflowAddition@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/overflowAddition~dark@2x.png"
    }
  ]
},
"overflowSignedSubtraction": {
  "alt" : null,
  "identifier" : "overflowSignedSubtraction",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/overflowSignedSubtraction@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/overflowSignedSubtraction~dark@2x.png"
    }
  ]
},
"overflowUnsignedSubtraction": {
  "alt" : null,
  "identifier" : "overflowUnsignedSubtraction",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/overflowUnsignedSubtraction@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/overflowUnsignedSubtraction~dark@2x.png"
    }
  ]
},
"vectorAddition": {
  "alt" : null,
  "identifier" : "vectorAddition",
  "type" : "image",
  "variants" : [
    {
      "traits" : [
        "2x",
        "light"
      ],
      "url" : "\/images\/vectorAddition@2x.png"
    },
    {
      "traits" : [
        "2x",
        "dark"
      ],
      "url" : "\/images\/vectorAddition~dark@2x.png"
    }
  ]
}
}
}